<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>ExploRide ‚Äì Wielka Mapa Urbexu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="/ExploMapa/manifest.json" />
  <meta name="theme-color" content="#000000" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" type="image/png" sizes="1080x1080" href="/ExploMapa/fav1080.png">
<link rel="apple-touch-icon" sizes="1080x1080" href="/ExploMapa/fav1080.png">

  <script src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js" crossorigin="anonymous"></script>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; font-family: sans-serif; background-color: #1e1e1e; color: #f0f0f0;}
    #map, #sidebar, #basemap-switcher, #layer-editor, #route-editor { display: none; }
    #map { position: absolute; top: 0; left: 300px; right: 225px; bottom: 0; }
    #map.pin-reposition,
    .leaflet-container.pin-reposition,
    #map.pin-reposition *,
    .leaflet-container.pin-reposition * {
      cursor: crosshair !important;
    }
    #sidebar {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 280px;
   border-color: #444;
    background: #2b2b2b;
    color: #f0f0f0;
      border-right: 1px solid #ccc;
      padding: 10px;
    }
    #sidebar-inner {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #lista-warstw {
      overflow-y: auto;
      flex: 1;
      border-top: 1px solid #444;
        padding-top: 8px; /* lub ile tam chcesz odstƒôpu */
    }
    #basemap-switcher {
      position: absolute;
      top: 0;
      right: 0;
      width: 200px;
      height: 100%;
      background-color: #2b2b2b;
      border-color: #444;
      color: #f0f0f0;
      border-left: 1px solid #ccc;
      padding: 10px;
      font-size: 12px !important;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      gap: 10px;
      overflow: hidden;
    }
    #basemap-content {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
    }
    #basemap-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: auto;
    }
    #basemap-actions button {
      width: 100%;
      background: #2b2b2b;
      border: 1px solid #444;
      border-radius: 4px;
      color: #f0f0f0;
      cursor: pointer;
      padding: 8px 10px;
      font-size: 13px;
      font-weight: 600;
    }
    #history-log {
      border-top: 1px solid #444;
      margin-top: 10px;
      padding-top: 5px;
      max-height: 150px;
      overflow-y: auto;
      font-size: 11px;
    }
    #layer-editor {
      position: absolute;
      top: 0;
      left: 300px;
      width: 200px;
      height: 100%;
      background-color: #2b2b2b;
      border-color: #444;
      color: #f0f0f0;
      border-left: 1px solid #ccc;
      padding: 10px;
      overflow-y: auto;
      z-index: 1550;
      pointer-events: auto;
    }
    #bulk-pin-panel {
      position: absolute;
      top: 0;
      left: 300px;
      width: 220px;
      background-color: #2b2b2b;
      border-left: 1px solid #ccc;
      border-color: #444;
      color: #f0f0f0;
      padding: 10px;
      z-index: 1560;
      display: none;
      box-sizing: border-box;
      box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    }
    #bulk-pin-panel h4 {
      margin: 0 0 6px;
      font-size: 14px;
    }
    #bulk-pin-panel .bulk-pin-count {
      font-size: 12px;
      margin-bottom: 8px;
    }
    #bulk-pin-panel .bulk-pin-hint {
      font-size: 11px;
      color: #c7c7c7;
      margin: 6px 0 10px;
    }
    #bulk-pin-panel .bulk-actions {
      display: flex;
      gap: 6px;
    }
    #bulk-pin-panel button {
      width: 100%;
      background: #2b2b2b;
      border: 1px solid #444;
      border-radius: 4px;
      color: #f0f0f0;
      cursor: pointer;
      padding: 6px 8px;
      font-size: 12px;
    }
    .route-input-group {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
    }
    .route-input-group input[type="text"] {
      flex: 1;
    }
    .route-input-group button {
      background: #2b2b2b;
      border: 1px solid #444;
      border-radius: 4px;
      color: #f0f0f0;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 18px;
      line-height: 1;
    }
    .route-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 8px;
    }
    .route-actions button {
      background: #2b2b2b;
      border: 1px solid #444;
      border-radius: 4px;
      color: #f0f0f0;
      cursor: pointer;
      padding: 6px 10px;
      font-size: 14px;
      flex: 1;
    }
    .route-actions button.route-clear {
      width: 34px;
      font-size: 18px;
      line-height: 1;
      padding: 4px 0;
      flex: 0;
    }
    .route-actions button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .route-mode-options {
      margin: 6px 0 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    #route-editor {
      position: absolute;
      top: 0;
      left: 300px;
      width: 200px;
      height: 100%;
      background-color: #2b2b2b;
      border-color: #444;
      color: #f0f0f0;
      border-left: 1px solid #ccc;
      padding: 10px;
      overflow-y: auto;
      z-index: 1550;
      pointer-events: auto;
      display: none;
    }
    .trasy-lista { margin-left: 15px; }
    .trasa-item { font-size: 12px; cursor: pointer; padding-left: 4px; }
    .route-line { stroke-width: 4; }
    .route-line:hover { filter: drop-shadow(0 0 3px black); }
    .plan-item { font-size: 12px; cursor: pointer; padding-left: 4px; display: flex; align-items: center; gap: 6px; }
    .plan-item .plan-name { flex: 1; text-decoration: underline; }
    .plan-item .plan-visibility { flex-shrink: 0; }
    .plan-option-panel {
      position: absolute;
      background: #2b2b2b;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 10px;
      z-index: 5000;
      color: #f0f0f0;
      width: 240px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.45);
    }
    .plan-transform-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 0;
      pointer-events: none;
      z-index: 4000;
    }
    .plan-handle {
      position: absolute;
      width: 14px;
      height: 14px;
      background: rgba(30, 136, 229, 0.9);
      border: 1px solid #e3f2fd;
      border-radius: 3px;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0d47a1;
      font-size: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35);
      opacity: 0.95;
    }
    .plan-handle:hover {
      background: #90caf9;
    }
    .plan-handle::after {
      content: '‚§°';
      pointer-events: none;
    }
    .plan-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .plan-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .plan-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .plan-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }
    .plan-rotate {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(245, 245, 245, 0.9);
      border: 1px solid #607d8b;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0d47a1;
      font-size: 14px;
      pointer-events: auto;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35);
    }
    .plan-rotate:hover {
      background: #cfd8dc;
    }
    .plan-rotate::after {
      content: '‚ü≥';
      pointer-events: none;
    }
    .plan-option-panel h4 { margin: 0 0 6px 0; font-size: 14px; }
    .plan-option-panel .row { margin-bottom: 8px; display: flex; gap: 6px; align-items: center; }
    .plan-option-panel label { font-size: 12px; }
    .plan-option-panel input[type="text"] { width: 100%; }
    .plan-option-panel input[type="range"] { width: 100%; }
    .plan-option-panel button { width: 100%; margin-top: 4px; }
    .plan-editor-panel {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #2b2b2b;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 10px;
      z-index: 4500;
      color: #f0f0f0;
      min-width: 280px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.45);
    }
    .plan-editor-panel h4 { margin: 0 0 6px 0; }
    .plan-editor-panel .row { margin-bottom: 6px; display: flex; gap: 6px; align-items: center; }
    .plan-editor-panel input[type="text"] { flex: 1; }
    .plan-editor-panel .hint { font-size: 12px; opacity: 0.8; }
    .plan-editor-panel .actions { display: flex; gap: 6px; }
    .route-time-tooltip.leaflet-tooltip {
      background: rgba(43, 43, 43, 0.92);
      border: 1px solid #444;
      color: #f0f0f0;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);
    }

    .route-time-tooltip.leaflet-tooltip::before {
      display: none;
    }
    .layer-separator {
      border-bottom: 1px solid #555;
      margin: 5px 0;
    }
    #wyszukiwarka { width: 80%; margin-bottom: 10px; padding: 5px; flex-shrink: 0; }
    .pinezka { 
      margin: 7px 0; cursor: pointer; color: #f0f0f0; font-size: 12px; 
      padding-bottom: 6px;
      border-bottom: 1px solid #444;
      margin-bottom: 6px;
             }
    .pinezka.selected {
      background: rgba(255, 255, 255, 0.08);
      border-radius: 4px;
      padding-left: 4px;
    }
    #narzedzia {
      margin-bottom: 10px;
    flex-shrink: 0;
    position: fixed !important;
    top: 50px;
    left: 315px;
    z-index: 1000; 
    }
    .tool-btn {
      font-size: 24px;
      background: #2b2b2b;
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
      font-family: "Noto Color Emoji", sans-serif;
    }
    .tool-btn img { border: none; border-radius: 4px; }
    .tool-btn.active { background: #444; }
    .pinezka.active { color: #007bff; font-weight: bold; }
    .pinezka:hover { text-decoration: underline; }
    .warstwa { margin-bottom: 10px; }
    .dragging { opacity: 0.5; }
    .warstwa h3 { margin: 5px 0; font-size: 16px; display: flex; align-items: center; cursor: pointer; }
    .warstwa input[type="checkbox"] { margin-right: 5px; }
    .layer-number { margin-right: 5px; color: #bbb; cursor: move; user-select: none; font-size: 12px}
    .layer-number.dragging { opacity: 0.5; }
    .pinezki-lista { margin-left: 10px; display: block; }
    .new-layer-controls { margin-top: 5px; }
    .new-layer-row { display: flex; align-items: center; gap: 6px; }
    #newLayerInput { flex: 1; min-width: 0; }
    .new-layer-cancel {
      background: transparent;
      border: 1px solid #555;
      color: #f0f0f0;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      cursor: pointer;
      line-height: 1;
    }
    .kml-import-btn {
      margin-top: 4px;
      background: none;
      border: none;
      padding: 0;
      color: #7fbaff;
      text-decoration: underline;
      cursor: pointer;
      font-size: 12px;
      text-align: left;
    }
    .ukryta { display: none; }
    .opacity-slider { width: 100%; }
    #ekran-logowania {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: white;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #loginBtn {
      font-size: 18px;
      padding: 10px 20px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .hillshade-dark { filter: grayscale(100%) brightness(60%); }
    .emoji-marker { background: none; border: none; }
    .emoji-sztosy {
  font-family: 'Noto Color Emoji', sans-serif;
  font-size: 22.4px;
  line-height: 25.6px;
  position: relative;
  color: inherit;
  text-shadow:
    /*
        -2px -2px 0 #000,
     2px -2px 0 #000,
    -2px  2px 0 #000,
     2px  2px 0 #000,
    */

    /* gruby z≈Çoty kontur - na wierzchu */
    -1px -1px 0 gold,
     1px -1px 0 orange,
    -1px  1px 0 gold,
     1px  1px 0 orange;

          
}
  .emoji-marker span {
  font-family: 'Noto Color Emoji', sans-serif;
  font-size: 12.4px;
  line-height: 25.6px;
}

    .emoji-marker span:not(.emoji-sztosy) {
  text-shadow:
    /*
    -1px -1px 0 #000,
     1px -1px 0 #000,
    -1px  1px 0 #000,
     1px  1px 0 #000;
  */
     filter: drop-shadow(0 0 1px black)
          drop-shadow(0 0 1px black)
          drop-shadow(0 0 1px black)
          drop-shadow(0 0 1px black);
}
    .emoji-inline {
width: 15px;
    height: 15px;
    vertical-align: TOP;
    }
    .hidden-text { display: none; }

    #geosearch-container {
      position: absolute;
      top: 10px;
      left: 310px;
      right: 600px;
      padding: 5px;
      z-index: 1000;
      display: flex;
    }
    #geosearch {
      flex: 1;
      padding: 5px;
    }
    #geosearchBtn {
      margin-left: 5px;
    }
    #geosearch-suggestions {
      position: absolute;
      top: 100%;
      left: 200px;
      background: #2b2b2be0;
      border: 1px solid #444;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 1001;
      margin-right: 50px;
    }
    #geosearch-suggestions div {
      padding: 4px;
      cursor: pointer;
    }
    #geosearch-suggestions div:hover {
      background: #444;
    }
    .unsaved {
      color: red;
    }
    .inactive {
      opacity: 0.5;
      color: #999;
      filter: saturate(50%);
    }
    #exportKML {
      background-color: #007bff;
      border-color: #0068d7;
    }
    #saveChanges {
      background-color: #28a745;
      border-color: #218838;
    }
    #saveChanges.unsaved {
      background-color: #dc3545;
      border-color: #b02a37;
    }
    #map.pin-cursor {
      cursor: url('https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2.png') 13 43, auto !important;
    }
      .leaflet-grab {
    cursor: default !important;
  }
     .leaflet-dragging .leaflet-grab {
    cursor: grabbing !important;
  }
    ::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

::-webkit-scrollbar-track {
  background: #2a2a2a;
}

::-webkit-scrollbar-thumb {
  background-color: #555;
  border-radius: 5px;
  border: 2px solid #2a2a2a;
}

::-webkit-scrollbar-thumb:hover {
  background-color: #777;
}

/* Scrollbar dla Firefox */
body, #sidebar, #basemap-switcher {
  scrollbar-width: thin;
  scrollbar-color: #555 #2a2a2a;
}
    #lista-warstw {
  scrollbar-width: thin;
  scrollbar-color: #555 #1e1e1e;
}

/* Dla Chrome, Edge, Safari */
#lista-warstw::-webkit-scrollbar {
  width: 8px;
}

#lista-warstw::-webkit-scrollbar-track {
  background: #1e1e1e;
}

#lista-warstw::-webkit-scrollbar-thumb {
  background-color: #555;
  border-radius: 4px;
}

#lista-warstw::-webkit-scrollbar-thumb:hover {
  background-color: #777;
}
    #logoNaglowek {
  text-align: center;
  font-weight: bold;
  font-size: 20px;
  margin: 0 0 10px 0;
  color: #f0f0f0;
}
.emoji-obrys {
  filter: drop-shadow(0 0 0.1px black)
          drop-shadow(1px 1px 1px black)
          drop-shadow(-1px -1px 1px black);
  vertical-align: middle;
  margin-right: 5px;
  border-radius: 2px;
}

.emoji-obrys-sztosy {
  filter: drop-shadow(0 0 0.1px gold)
          drop-shadow(1px 1px 1px orange)
          drop-shadow(-1px -1px 1px gold);
  drop-shadow(0 0 2px black)
          drop-shadow(2px 2px 2px black)
          drop-shadow(-2px -2px 2px black);
  vertical-align: middle;
  margin-right: 5px;
  border-radius: 2px;
}
.popup-container {
  position: relative;
  padding-top: 6px;
}
.edit-popup {
  min-width: 300px;
}
.popup-edit-btn {
  position: static;
  margin-left: auto;
}
.popup-edit-row {
  display: flex;
  justify-content: flex-end;
  margin-top: 6px;
}
.popup-route-actions {
  display: flex;
  gap: 6px;
  margin-top: 5px;
}

.popup-route-btn,
.popup-direct-route-btn {
  flex: 1;
  background: #2b2b2b;
  border: 1px solid #444;
  border-radius: 4px;
  color: #f0f0f0;
  cursor: pointer;
  font-size: 12px;
  padding: 4px 6px;
}

.popup-direct-route-btn {
  font-weight: 600;
}
.popup-photo {
  width: 100%;
  max-height: 150px;
  object-fit: cover;
  cursor: pointer;
}
.photo-gallery {
  display: flex;
  overflow-x: auto;
  gap: 2px;
  margin-bottom: 4px;
}
.popup-info-item {
  margin-bottom: 2px;
  margin-top: 5px;
}
.photo-item {
  position: relative;
  flex: 0 0 auto;
}
.photo-delete {
  position: absolute;
  top: 2px;
  right: 2px;
  background: rgba(0, 0, 0, 0.6);
  color: #fff;
  font-size: 14px;
  padding: 2px;
  cursor: pointer;
  display: none;
}
.edit-popup .photo-item:hover .photo-delete {
  display: block;
}
#photoModal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  justify-content: center;
  align-items: center;
  z-index: 2000;
}
#photoModal img {
  max-width: 90%;
  max-height: 90%;
}
#photoModalClose {
  position: absolute;
  top: 20px;
  right: 30px;
  color: #fff;
  font-size: 32px;
  cursor: pointer;
  z-index: 2101;
}
#photoModalDelete {
  position: absolute;
  top: 20px;
  right: 80px;
  color: #fff;
  font-size: 32px;
  cursor: pointer;
  z-index: 2101;
  display: none;
}

#deleteModal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  justify-content: center;
  align-items: center;
  z-index: 2147483605;
  color: #fff;
}

#deleteModalContent {
  background: #2b2b2b;
  border: 1px solid #444;
  padding: 20px;
  text-align: center;
}

#deleteModal button {
  margin: 5px;
}
#layerDeleteModal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  justify-content: center;
  align-items: center;
  z-index: 2147483605;
  color: #fff;
}
#layerDeleteModalContent {
  background: #2b2b2b;
  border: 1px solid #444;
  padding: 20px;
  text-align: center;
}
#layerDeleteModal button {
  margin: 5px;
}

.leaflet-popup-content {
  max-width: 300px;
}

.leaflet-popup-content-wrapper {
  background: #2b2b2b;
  color: #f0f0f0;
  border: 1px solid #444;
}

.leaflet-popup-tip {
  background: #2b2b2b;
  border: 1px solid #444;
}

.leaflet-popup-close-button {
  color: #f0f0f0;
}

    .leaflet-popup {
    position: absolute;
    text-align: center;
    margin-bottom: 40px;
}

.popup-description.scrollable {
  max-height: 150px;
  overflow-y: auto;
}
.sztosy-gwiazda {
  position: absolute;
  top: -8px;
  right: -6px;
  font-size: 18px;
  padding: 1px;
  line-height: 1;
  z-index: 10;
       filter: drop-shadow(0 0 0.2px red)
          drop-shadow(0 0 1px red)
          drop-shadow(0 0 1px red)
          drop-shadow(0 0 1px red);
}
.zwiedzone-check {
  position: absolute;
  bottom: -6px;
  right: -6px;
  z-index: 10;
}
.status-icon {
  position: absolute;
 top: -1px;
  bottom: auto;
  z-index: 20;
  text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 1px #000;
  filter: drop-shadow(0 0 0.5px black) drop-shadow(1px 1px 0 black) drop-shadow(-1px -1px 0 black);
}

.status-icon.sztosy {
  top: -1px;
  bottom: auto;
  z-index: 20;
}

@media (max-width: 600px) {
  .status-icon {
    transform: scale(0.33);
    transform-origin: top left;
  }
}

.checkmark-obrys {
  filter: drop-shadow(0 0 0.5px black) drop-shadow(1px 1px 0 black) drop-shadow(-1px -1px 0 black);
  border-radius: 2px;
}

#loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 2000;
  display: none;
}
.loader {
  border: 8px solid #f3f3f3;
  border-top: 8px solid #007bff;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  animation: spin 1s linear infinite;
}
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

#toggleLayers { display: none; }
#toggleBasemaps { display: none; }

@media (max-width: 700px) {
  #map { left: 0 !important; right: 0 !important; }
  #sidebar { position: fixed; transform: translateX(-100%); transition: transform 0.3s ease; width: 260px; z-index: 1500; }
  #sidebar.show { transform: translateX(0); }
  #basemap-switcher { position: fixed; top: 0; right: 0; transform: translateX(100%); transition: transform 0.3s ease; height: 100%; z-index: 1500; }
  #basemap-switcher.show { transform: translateX(0); }
  #narzedzia { left: 10px; top: 104px; z-index: 900; }
  #geosearch-container { left: 10px; right: 10px; top: 52px; z-index: 900; }
  #gpsFollowBtn {
    position: fixed;
    bottom: 20px;
    right: 15px;
    z-index: 1000;
    background: #2b2b2b;
    color: #f0f0f0;
    border: 1px solid #444;
    padding: 8px 12px;
    border-radius: 4px;
    display: none;
  }
  #exportKML { display: none; }
  .leaflet-popup { z-index: 2147483600 !important; }
  .leaflet-control-zoom { left: 10px; }
  #toggleLayers { position: fixed; top: 10px; left: 10px; z-index: 1600; background: #2b2b2b; color: #f0f0f0; border: 1px solid #444; padding: 5px 10px; display: block; }
  #toggleBasemaps { position: fixed; top: 10px; right: 10px; z-index: 1600; background: #2b2b2b; color: #f0f0f0; border: 1px solid #444; padding: 5px 10px; display: block; }
}

/* --- FIX: normalny rozmiar ikon statusu na mobile i desktop --- */
.status-grid label {
  display: flex;
  align-items: center;
  gap: 6px;
  line-height: 1.2;
}

.status-grid input[type="checkbox"] {
  margin-right: 4px; /* backup gdy flex gap nie z≈Çapie */
}

/* Emoji w statusach (tak≈ºe po podmianie przez twemoji) */
.status-grid .status-emoji,
.status-grid .status-emoji img,
#mobilePinModal .status-grid img.emoji,
#mobilePinModal .status-grid .emoji,
#mobilePinModal .status-grid img {
  width: 1em !important;
  height: 1em !important;
  display: inline-block;
  vertical-align: -0.15em;
}

/* Zielony ptaszek ze statusu ‚ÄûZwiedzone‚Äù */
.status-grid .checkmark-obrys {
  width: 1em !important;
  height: 1em !important;
}

/* (opcjonalnie) globalny bezpiecznik na twemoji, ≈ºeby nigdzie nie wybucha≈Çy */
img.emoji {
  width: 1em;
  height: 1em;
  vertical-align: -0.15em;
}

/* FIX: brak rozciƒÖgania w pickerze */
.emoji-picker-grid img {
  height: 1.8em !important;   /* mo≈ºesz daƒá 1em, je≈õli wolisz mniejsze */
  width: auto !important;       /* klucz: zachowaj proporcje */
  object-fit: contain;
  vertical-align: -0.15em;
}

/* podglƒÖd przy przycisku z emoji (je≈õli chcesz te≈º go odchudziƒá) */
.emoji-picker-preview {
  height: 1.8em;
  width: auto;
}

    #toast {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      display: none;
      z-index: 2000;
      pointer-events: none;
    }
    .info-btn {
      margin-left: 4px;
      font-size: 10px;
      padding: 0 4px;
      cursor: pointer;
    }

    #map-date-controls {
      margin-bottom: 5px;
      font-size: 12px;
    }
    #map-date-badge {
      background: #444;
      padding: 2px 4px;
      border-radius: 4px;
    }
    #map-year-select {
      margin-left: 5px;
    }

  </style>
</head>
<body>
  <div id="offlineBar" style="display:none;position:fixed;top:0;left:0;right:0;background:#cc0000;color:#fff;text-align:center;padding:4px;z-index:2000;">Offline</div>
  <div id="banner" style="display:none;position:fixed;top:40px;left:50%;transform:translateX(-50%);background:#333;color:#fff;padding:6px 12px;border-radius:4px;z-index:2000;"></div>
  <div id="toast"></div>
  <div id="ekran-logowania"><button id="loginBtn">Zaloguj siƒô przez Google</button></div>
  <div id="loading"><div class="loader"></div></div>
  <div id="sidebar">
    <div id="sidebar-inner">
      <h2 id="logoNaglowek">ExploMapy</h2>
      <input type="text" id="wyszukiwarka" placeholder="Szukaj pinezki...">
      <select id="sortowanie">
        <option value="dateDesc">Sortuj wg daty ‚Äì od najnowszych</option>
        <option value="dateAsc">Sortuj wg daty ‚Äì od najstarszych</option>
        <option value="nameAsc">Sortuj alfabetycznie A‚ÜíZ</option>
        <option value="nameDesc">Sortuj alfabetycznie Z‚ÜíA</option>
      </select>
      <details id="filterKategorie">
        <summary>Filtruj kategorie</summary>
        <div id="kategorie-lista"></div>
      </details>
      <details id="filterStatusy">
        <summary>Filtruj statusy</summary>
        <div id="status-lista"></div>
      </details>
      <button id="addLayerBtn">+ Nowa warstwa</button>
      <div id="newLayerControls" class="new-layer-controls" style="display:none;">
        <div class="new-layer-row">
          <input type="text" id="newLayerInput" placeholder="Nazwa warstwy">
          <button type="button" id="cancelNewLayer" class="new-layer-cancel" aria-label="Anuluj wprowadzanie warstwy">‚úñ</button>
        </div>
        <button type="button" id="importKmlBtn" class="kml-import-btn">importuj z .kml</button>
        <input type="file" id="importKmlInput" accept=".kml" style="display:none;">
      </div>
        <button id="collapseAllLayers">Rozwi≈Ñ wszystkie warstwy</button>
      <button id="toggleVisibility">Ukryj wszystkie warstwy</button>
      <button id="loadPinsBtn">Za≈Çaduj pinezki</button>
      <div id="lista-warstw"></div>
      <button id="emojiToolBtn">Emoji Tool</button>
      <button id="syncBtn">Synchronizuj (<span id="syncCount">0</span>)</button>
    </div>
  </div>
  <div id="bulk-pin-panel">
    <h4>Masowa zmiana warstwy</h4>
    <div class="bulk-pin-count">Zaznaczone: 0</div>
    <input type="text" id="bulkLayerInput" placeholder="Wybierz warstwƒô" style="width: 100%">
    <div class="bulk-pin-hint">Shift wybiera zakres, Ctrl/‚åò dodaje/usuwa z zaznaczenia.</div>
    <div class="bulk-actions">
      <button id="bulkApplyLayer">Zatwierd≈∫ zmianƒô warstwy</button>
      <button id="bulkClearSelection">Wyczy≈õƒá zaznaczenie</button>
    </div>
  </div>
  <div id="geosearch-container">
    <input type="text" id="geosearch" placeholder="Szukaj adresu lub wsp√≥≈Çrzƒôdnych...">
    <button id="geosearchBtn" class="tool-btn" title="Szukaj">üîç</button>
    <div id="geosearch-suggestions"></div>
  </div>
  <div id="narzedzia">
    <button id="handTool" class="tool-btn">
      <img src="https://cdn.jsdelivr.net/gh/twitter/twemoji@latest/assets/svg/1f44b.svg" width="24" height="24" alt="hand">
    </button>
    <button id="pinTool" class="tool-btn">
      <img src="https://cdn.jsdelivr.net/gh/twitter/twemoji@latest/assets/svg/1f4cd.svg" width="24" height="24" alt="pin">
    </button>
    <button id="undoBtn" class="tool-btn" title="Cofnij">‚¨ÖÔ∏è</button>
    <button id="redoBtn" class="tool-btn" title="Pon√≥w">‚û°Ô∏è</button>
  </div>
  <div id="map"></div>
  <div id="planEditor" class="plan-editor-panel" style="display:none;">
    <h4>Dodawanie planu</h4>
    <div class="row"><input type="text" id="planNameInput" placeholder="Nazwa planu"></div>
    <div class="row"><button id="planChangeImage">Zmie≈Ñ obraz</button></div>
    <div class="row">
      <label for="planScale">Skala</label>
      <input type="range" id="planScale" min="25" max="300" value="100">
    </div>
    <div class="row">
      <label for="planOpacity">Przezroczysto≈õƒá</label>
      <input type="range" id="planOpacity" min="20" max="100" value="100">
    </div>
      <div class="hint">Przytrzymaj i przeciƒÖgnij plan, aby zmieniƒá jego pozycjƒô. Z≈Çap za naro≈ºnik, aby skalowaƒá, lub za zewnƒôtrznƒÖ okrƒÖg≈ÇƒÖ strza≈Çkƒô, aby obr√≥ciƒá obraz.</div>
    <div class="actions">
      <button id="planCancel">Anuluj</button>
      <button id="planConfirm">Zatwierd≈∫</button>
    </div>
  </div>
  <div id="planOptions" class="plan-option-panel" style="display:none;"></div>
  <button id="toggleLayers">‚ò∞ Warstwy</button>
  <button id="toggleBasemaps">‚ò∞ Mapy</button>
  <div id="basemap-switcher">
    <div id="basemap-content">
      <h3>Rodzaj mapy</h3>
      <div id="map-date-controls"><span id="map-date-badge"></span><select id="map-year-select" style="display:none;"></select></div>
      <details>
        <summary><strong>Bazy</strong></summary>
        <label><input type="radio" name="basemap" value="osm"> Mapa podstawowa</label><br>
        <label><input type="radio" name="basemap" value="sat" checked> Esri World Imagery</label><br>
        <label><input type="radio" name="basemap" value="hill"> Cieniowanie</label><br>
        <label><input type="radio" name="basemap" value="orto-wmts-std"> Orto (WMTS ‚Äì Standard)<button type="button" class="info-btn" data-info="WMTS szybkie kafle">i</button></label><br>
        <label><input type="radio" name="basemap" value="orto-wmts-hi"> Orto HighRes (WMTS ‚Äì HighResolution)<button type="button" class="info-btn" data-info="WMTS szybkie kafle">i</button></label><br>
        <label><input type="radio" name="basemap" value="orto-wms-std"> Orto (WMS ‚Äì Standard)<button type="button" class="info-btn" data-info="WMS pe≈Çny render">i</button></label><br>
        <label><input type="radio" name="basemap" value="orto-wms-hi"> Orto HighRes (WMS ‚Äì HighResolution)<button type="button" class="info-btn" data-info="WMS pe≈Çny render">i</button></label><br>
        <label><input type="radio" name="basemap" value="orto-wms-std-time"> Orto archiwalne (WMS Time ‚Äì Standard)</label><br>
        <label><input type="radio" name="basemap" value="orto-wms-hi-time"> Orto archiwalne (WMS Time ‚Äì HighRes)</label><br>
        <label><input type="radio" name="basemap" value="true-orto"> True Ortho (WMS)<button type="button" class="info-btn" data-info="TrueOrtho ‚Äì brak zniekszta≈Çce≈Ñ od wysoko≈õci">i</button></label><br>
        <label><input type="radio" name="basemap" value="otm-trails"> OpenTopoMap + Szlaki (Waymarked)</label><br>
      </details>
      <div class="layer-separator"></div>
      <details>
        <summary><strong>Nak≈Çadki</strong></summary>
        <div class="overlay-item">
          <label><input type="checkbox" id="overlay-arch-std"> Orto Archiwalne ‚Äì Standard (WMS)
            <button type="button" class="opacity-btn" data-target="archStd">‚öô</button>
            <button type="button" class="info-btn" data-info="Archiwum ‚Äì historyczne ujƒôcia">i</button>
          </label><br>
          <input type="range" min="0" max="100" value="100" class="opacity-slider ukryta" id="opacity-archStd">
        </div>
        <div class="overlay-item">
          <label><input type="checkbox" id="overlay-arch-hi"> Orto Archiwalne ‚Äì HighRes (WMS)
            <button type="button" class="opacity-btn" data-target="archHi">‚öô</button>
            <button type="button" class="info-btn" data-info="Archiwum ‚Äì historyczne ujƒôcia">i</button>
          </label><br>
          <input type="range" min="0" max="100" value="100" class="opacity-slider ukryta" id="opacity-archHi">
        </div>
        <div class="overlay-item">
          <label><input type="checkbox" id="overlay-shade"> Cieniowanie (Geoportal WMTS)
            <button type="button" class="opacity-btn" data-target="shade">‚öô</button>
            <button type="button" class="info-btn" data-info="Cieniowanie terenu z Geoportalu">i</button>
          </label><br>
          <input type="range" min="0" max="100" value="100" class="opacity-slider ukryta" id="opacity-shade">
        </div>
      </details>

      <h3>Widok ulic</h3>
      <label><input type="radio" name="streets" value="full" checked> Wszystkie ulice</label><br>
      <label><input type="radio" name="streets" value="main"> Tylko g≈Ç√≥wne trasy</label><br>
      <label><input type="radio" name="streets" value="none"> Brak ulic</label><br>

      <div id="route-controls">
        <h3>Wyznacz trasƒô</h3>
        <div class="route-input-group">
          <input type="text" id="routeStart" placeholder="Punkt poczƒÖtkowy">
          <button id="routeUseCurrent" type="button" title="Ustaw mojƒÖ lokalizacjƒô">üìç</button>
        </div>
        <div class="route-input-group">
          <input type="text" id="routeEnd" placeholder="Punkt ko≈Ñcowy">
        </div>
        <div class="route-mode-options">
          <label><input type="radio" name="routeMode" value="driving" checked> Trasa samochodowa</label>
          <label><input type="radio" name="routeMode" value="walking"> Trasa piesza</label>
        </div>
        <div class="route-actions">
          <button id="routeCalculate" type="button">Poka≈º trasƒô</button>
          <button id="routeClear" type="button" class="route-clear" title="Usu≈Ñ wyznaczonƒÖ trasƒô">X</button>
        </div>
      </div>
      <h3>Historia edycji</h3>
      <div id="history-log"></div>
    </div>
    <div id="basemap-actions">
      <button id="exportKML">Zapisz do .KML</button>
      <button id="saveChanges">Zapisz edycjƒô mapy</button>
    </div>
  </div>
  <div id="layer-editor">
    <h3>Edycja warstwy</h3>
    <input type="text" id="layerEditName" placeholder="Nazwa warstwy"><br>
    <input type="number" id="layerEditOrder" min="1" style="width:70px;"> <button id="layerEditSave" onclick="applyLayerEdits()">Zastosuj</button><br>
    <input id="layerEditEmoji" placeholder="Emoji warstwy" style="width:100%"><br>
    <div id="layerEditDefaultVisibility">
      <div>Domy≈õlna widoczno≈õƒá:</div>
      <label><input type="radio" name="layerDefaultVisibility" id="layerDefaultVisible" value="visible"> Domy≈õlnie pokazana</label><br>
      <label><input type="radio" name="layerDefaultVisibility" id="layerDefaultHidden" value="hidden"> Domy≈õlnie ukryta</label>
    </div>
    <button id="layerEditDelete">Usu≈Ñ warstwƒô</button>
    <button id="layerEditClose" onclick="closeLayerEditor()">Zamknij</button>
  </div>
  <div id="route-editor">
    <h3>Edycja trasy</h3>
    <input type="text" id="routeEditName" placeholder="Nazwa trasy"><br>
    <textarea id="routeEditDesc" placeholder="Opis trasy" style="width:100%"></textarea><br>
    <input type="color" id="routeEditColor"><br>
    <label for="routeEditOpacity">Przezroczysto≈õƒá trasy</label><br>
    <input type="range" id="routeEditOpacity" min="0" max="100" value="100" step="5">
    <span id="routeEditOpacityValue">100%</span><br>
    <button id="routeEditDelete">Usu≈Ñ trasƒô</button>
    <button id="routeEditClose" onclick="closeRouteEditor()">Zamknij</button>
    <button id="routeEditApply" onclick="applyRouteEdits()">Zastosuj</button>
  </div>
  <button id="gpsFollowBtn">GPS</button>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
  <script src="offline-uploads.js"></script>
  <script src="firestore-setup.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="leaflet-tilelayer-wmts.js"></script>

  <script>
    const DEFAULT_ROUTE_COLOR = '#00ccff';
    const DEFAULT_ROUTE_OPACITY = 1;

    const emojiList = window.emojiList = [];
    const emojiMap = window.emojiMap = {};
    const emojiListListeners = new Set();
    let emojiListResolver;
    const emojiListReady = new Promise(res => (emojiListResolver = res));
    function notifyEmojiListUpdated() {
      emojiListListeners.forEach(listener => listener(emojiList));
    }
    function subscribeEmojiList(listener) {
      emojiListListeners.add(listener);
      return () => emojiListListeners.delete(listener);
    }
    db.collection('emoji-list').onSnapshot(snapshot => {
      const docs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      docs.sort((a, b) => {
        const na = parseInt(String(a.id).replace('emoji', '')) || 0;
        const nb = parseInt(String(b.id).replace('emoji', '')) || 0;
        return na - nb;
      });
      emojiList.length = 0;
      Object.keys(emojiMap).forEach(k => delete emojiMap[k]);
      docs.forEach(e => { emojiList.push(e); emojiMap[e.id] = e.url; });
      if (emojiListResolver) { emojiListResolver(); emojiListResolver = null; }
      notifyEmojiListUpdated();
    }, err => {
      console.error('‚ùå B≈ÇƒÖd pobierania emoji-list:', err);
      if (emojiListResolver) { emojiListResolver(); emojiListResolver = null; }
    });

    function resolveEmoji(val) {
      if (!val) return val;
      return emojiMap[val] || val;
    }

    async function addEmojiToList(url, info = '', logger = console.log) {
      await emojiListReady;
      const nextNum = emojiList.reduce((m, e) => {
        const n = parseInt(String(e.id).replace('emoji', '')) || 0;
        return Math.max(m, n);
      }, 0) + 1;
      const newId = `emoji${nextNum}`;
      const data = { id: newId, url, info };
      emojiList.push(data);
      emojiMap[newId] = url;
      notifyEmojiListUpdated();
      try {
        await db.collection('emoji-list').doc(newId).set(data);
        logger(`üíæ Dodano ${newId} do Firebase`);
      } catch (e) {
        logger(`‚ùå B≈ÇƒÖd zapisu do Firebase: ${e.message}`);
      }
      return newId;
    }
    window.addEmojiToList = addEmojiToList;

function slugify(str) {
  return str
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9_-]/gi, "_")
    .toLowerCase();
}

    function sanitize(str) {
      return String(str || '').replace(/[\/%?#]/g, '_');
    }

    function generateSuffix(len = 6) {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let out = '';
      for (let i = 0; i < len; i++) {
        out += chars[Math.floor(Math.random() * chars.length)];
      }
      return out;
    }

    function isFirebaseStorage(u) {
      try { return new URL(u).hostname.includes('firebasestorage.googleapis.com'); }
      catch { return false; }
    }

    function isMyMapsHostedImage(u) {
      try {
        const url = new URL(u);
        return url.hostname === 'mymaps.usercontent.google.com' &&
               url.pathname.includes('/hostedimage/');
      } catch { return false; }
    }

    // Proxy do samego wy≈õwietlania (niezale≈ºny od ciasteczek Google).
    // U≈ºywamy images.weserv.nl ‚Äì podajemy URL bez protoko≈Çu.
    function proxyImage(u) {
      const noScheme = u.replace(/^https?:\/\//, '');
      // output=jpg zwiƒôksza szanse ‚Äûzwyk≈Çego‚Äù Content-Type
      return `https://images.weserv.nl/?url=${encodeURIComponent(noScheme)}&output=jpg`;
    }

    // Dla Firebase dopinamy ?alt=media. Dla MyMaps od razu proxy.
    function normalizePhotoUrl(u) {
      try {
        if (!u) return u;
        if (isFirebaseStorage(u)) {
          const url = new URL(u);
          if (!url.searchParams.has('alt')) url.searchParams.set('alt', 'media');
          return url.toString();
        }
        if (isMyMapsHostedImage(u)) {
          return proxyImage(u);
        }
        return u;
      } catch {
        return u;
      }
    }

    function imgWithFallback(url) {
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.decoding = 'async';
      img.src = normalizePhotoUrl(url);
      img.onerror = function () {
        if (!img.dataset.fallback) {
          img.dataset.fallback = '1';
          img.src = proxyImage(url);
        }
      };
      return img;
    }

    // === [CODEx ADDED] Kompresja obraz√≥w ===
    const IMG_COMPRESS = {
      maxEdge: 1600,   // d≈Çu≈ºszy bok skalujemy do 1600 px
      quality: 0.82,   // jako≈õƒá JPEG
      targetKB: 350,   // docelowy rozmiar ~350 KB (0 = wy≈ÇƒÖcz)
      minQuality: 0.6, // nie schod≈∫ ni≈ºej
      step: 0.06,      // krok obni≈ºania jako≈õci
    };

    async function compressDataUrl(dataUrl, opts = {}) {
      const cfg = { ...IMG_COMPRESS, ...opts };

      // Je≈õli ma≈Çy JPEG i brak targetu ‚Äî zwr√≥ƒá jak jest
      if (!cfg.targetKB && dataUrl.startsWith('data:image/jpeg') && dataUrl.length < 250_000) {
        return dataUrl;
      }

      const img = await new Promise((res, rej) => {
        const i = new Image();
        i.onload = () => res(i);
        i.onerror = rej;
        i.src = dataUrl;
      });

      let { width, height } = img;
      const longer = Math.max(width, height);

      // Skalowanie do maxEdge
      let canvas = document.createElement('canvas');
      let ctx = canvas.getContext('2d', { alpha: false });

      if (longer > cfg.maxEdge) {
        const scale = cfg.maxEdge / longer;
        width = Math.round(width * scale);
        height = Math.round(height * scale);
      }

      canvas.width = width;
      canvas.height = height;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, width, height);

      let q = cfg.quality;
      let out = canvas.toDataURL('image/jpeg', q);

      if (cfg.targetKB > 0) {
        const targetBytes = cfg.targetKB * 1024;
        let iter = 0;
        while (out.length > targetBytes && q > cfg.minQuality && iter < 6) {
          q = Math.max(cfg.minQuality, q - cfg.step);
          out = canvas.toDataURL('image/jpeg', q);
          iter++;
        }
      }

      canvas.width = 0; canvas.height = 0; canvas = null; ctx = null;
      return out;
    }

    document.getElementById("loginBtn").addEventListener("click", () => {
      const provider = new firebase.auth.GoogleAuthProvider();
      firebase.auth().signInWithPopup(provider);
    });

    firebase.auth().onAuthStateChanged(user => {
      if (!user) return;
      if (user.email !== "eksplorajder@gmail.com") {
        alert("Brak dostƒôpu.");
        return;
      }
      document.getElementById("ekran-logowania").style.display = "none";
      document.getElementById("map").style.display = "block";
      document.getElementById("sidebar").style.display = "block";
      document.getElementById("basemap-switcher").style.display = "block";
      initMap();
      loadLayersFromFirestore().then(() => {
        if (window.innerWidth <= 700) {
          loadNewPinsFromLocal();
          generujListeWarstw();
        } else {
          zaladujPinezkiZFirestore();
        }
        initGeoSearch();
        setupMobile();
        initRouteSearch();
        if (window.innerWidth <= 700) {
          const loadBtn = document.getElementById('loadPinsBtn');
          if (loadBtn) {
            loadBtn.addEventListener('click', () => {
              shouldApplyDefaultLayerState = true;
              initialLayerVisibilitySet = true;
              shouldIgnoreStoredLayerState = true;
              localStorage.removeItem(LAYER_COLLAPSE_STORAGE_KEY);
              localStorage.removeItem(LAYER_VISIBILITY_STORAGE_KEY);
              zaladujPinezkiZFirestore();
              loadBtn.style.display = 'none';
            }, { once: true });
          }
        }
      });
    });

    let map, baseLayer, routingLayer, roadsLayer, baseTileErrorHandler, waymarkedErrorHandler;
    let pinRepositionState = null;
    let currentBase = 'sat';
    let loadingCount = 0;
    let baseLayerLoadToken = 0;
    let baseLayerLoadingCount = 0;
    let baseLayerLoadingHandler = null;
    let baseLayerLoadedHandler = null;
    function showLoading() {
      const el = document.getElementById('loading');
      if (loadingCount === 0 && el) el.style.display = 'block';
      loadingCount++;
    }
    function hideLoading() {
      if (loadingCount > 0) loadingCount--;
      if (loadingCount === 0) {
        const el = document.getElementById('loading');
        if (el) el.style.display = 'none';
      }
    }
    function resetBaseLayerLoading() {
      if (baseLayerLoadingCount > 0) {
        for (let i = 0; i < baseLayerLoadingCount; i++) hideLoading();
        baseLayerLoadingCount = 0;
      }
    }
    function showToast(msg) {
      const el = document.getElementById('toast');
      if (!el) return;
      el.textContent = msg;
      el.style.display = 'block';
      setTimeout(() => { el.style.display = 'none'; }, 3000);
    }
    const LAYER_ORDER_STORAGE_KEY = 'warstwaOrder';
    const LAYER_COLLAPSE_STORAGE_KEY = 'warstwaCollapsed';
    const LAYER_VISIBILITY_STORAGE_KEY = 'warstwaVisibility';
    const LAYER_STATE_PRESERVE_FLAG_KEY = 'warstwaPreserveStateOnce';
    const PINTEREST_LAYER_NAME = 'pinterest_diane_g';
    const PINTEREST_PINS_COLLECTION = 'pinterest_diane_g';

    const shouldRestoreLayerState = localStorage.getItem(LAYER_STATE_PRESERVE_FLAG_KEY) === '1';
    // When the page is opened normally we want layer visibility/collapse to reset.
    // We only restore the stored state immediately after a save-triggered reload.
    let shouldIgnoreStoredLayerState = !shouldRestoreLayerState;
    if (shouldRestoreLayerState) {
      localStorage.removeItem(LAYER_STATE_PRESERVE_FLAG_KEY);
    } else {
      localStorage.removeItem(LAYER_COLLAPSE_STORAGE_KEY);
      localStorage.removeItem(LAYER_VISIBILITY_STORAGE_KEY);
    }

    const warstwy = {};
    let wszystkiePinezki = [];
    let draggedLayer = null;
    let highlightedItem = null;
    let highlightedMarker = null;
    let pinHighlightCircle = null;
    let zmianyDoZapisania = {};
    let shouldWarnBeforeUnload = false;
    let nowePinezki = [];
    let localPinsLoaded = false;
    const photosMap = {};
    let sortMode = 'dateDesc';
    const categories = new Set();
    let selectedCategories = new Set();
    const statusOptions = [
      {key: 'niedostepne', label: 'Niedostƒôpne ‚õî', matches: p => p.niedostepne || p.nieaktywne},
      {key: 'doSprawdzenia', label: 'Do sprawdzenia ‚ùî', matches: p => p.doSprawdzenia},
      {key: 'zdewastowane', label: 'Zdewastowane üí•', matches: p => p.zdewastowane},
      {key: 'zwiedzone', label: 'Zwiedzone <img src="https://upload.wikimedia.org/wikipedia/commons/0/03/Green_check.svg" width="16" height="16" class="checkmark-obrys">', matches: p => p.zwiedzone},
      {key: 'wyroznione', label: 'Wyr√≥≈ºnione ‚≠ê', matches: p => p.wyroznione},
      {key: 'zamkniete', label: 'Zamkniƒôte üîê', matches: p => p.zamkniete},
      {key: 'tajne', label: 'Tajne ü§´', matches: p => p.tajne}
    ];
    let selectedStatuses = new Set();
    const layerDocs = {};
    const layerNamesById = {};
    let sztosyId = null;
    let visitedId = null;
    let movingLayerId = null;
    const orangeLayerId = 'Pwgv6ssxu9sTvrjTaB43';
    let layerEmojiChanges = {};
    let layerDefaultVisibilityChanges = {};
    let layersToAdd = [];
    let layersToDelete = [];
    let pinsToDelete = [];
      const planLayers = {};
      let activePlanPlacement = null;
      let planOptionsState = null;
      let planTransformState = null;
    let initialLayerOrder = [];
    let layerOrderChanged = false;
    let currentTool = "hand";
    let initialLayerVisibilitySet = false;
    let shouldApplyDefaultLayerState = window.innerWidth > 700;
    const rysowaneTrasy = new L.FeatureGroup();
    window.localTrasy = [];
    let drawingRoute = false;
    let activeRoutePin = null;
    const handBtn = document.getElementById("handTool");
    const pinBtn = document.getElementById("pinTool");
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const mapEl = document.getElementById("map");
    let searchLayer = null;
    let searchMarker = null;
    const addressCache = new Map();
    const addressPromises = new Map();
    let layerDomRefs = {};
    let currentSearchTerm = '';
    const selectedPinIds = new Set();
    let lastSelectedPinId = null;

    const bulkPanel = document.getElementById('bulk-pin-panel');
    const bulkLayerInput = document.getElementById('bulkLayerInput');
    const bulkApplyLayerBtn = document.getElementById('bulkApplyLayer');
    const bulkClearSelectionBtn = document.getElementById('bulkClearSelection');
    const bulkCountEl = bulkPanel ? bulkPanel.querySelector('.bulk-pin-count') : null;

    function updateBulkPanel() {
      if (!bulkPanel) return;
      const count = selectedPinIds.size;
      bulkPanel.style.display = count > 1 ? 'block' : 'none';
      if (bulkCountEl) bulkCountEl.textContent = `Zaznaczone: ${count}`;
    }

    function updateSelectionStyles() {
      document.querySelectorAll('#lista-warstw .pinezka').forEach(el => {
        const pinId = el.dataset.pinId;
        if (pinId && selectedPinIds.has(pinId)) {
          el.classList.add('selected');
        } else {
          el.classList.remove('selected');
        }
      });
    }

    function clearBulkSelection() {
      selectedPinIds.clear();
      lastSelectedPinId = null;
      updateSelectionStyles();
      updateBulkPanel();
    }

    function handleBulkLayerSelection() {
      if (!bulkLayerInput) return;
      const layerName = bulkLayerInput.value.trim();
      if (!layerName) {
        showToast('Wybierz warstwƒô dla zaznaczonych pinezek.');
        return;
      }
      if (selectedPinIds.size === 0) {
        showToast('Najpierw zaznacz pinezki na li≈õcie.');
        return;
      }
      if (!warstwy[layerName]) {
        addLayer(layerName);
      }
      const updatedLayerId = layerDocs[layerName] || null;
      const pins = Array.from(selectedPinIds)
        .map(id => wszystkiePinezki.find(p => String(p.id) === id))
        .filter(Boolean);
      pins.forEach(pin => {
        markPinUnsaved(pin.slug);
        const pending = zmianyDoZapisania[pin.id] || {};
        pending.warstwa = layerName;
        pending.warstwaId = updatedLayerId;
        zmianyDoZapisania[pin.id] = pending;
        applyPinData(pin, { warstwa: layerName, warstwaId: updatedLayerId });
      });
      generujListeWarstw();
      updateSaveButton();
      showToast(`Przeniesiono ${pins.length} pinezek do warstwy "${layerName}".`);
    }

    if (bulkClearSelectionBtn) {
      bulkClearSelectionBtn.addEventListener('click', () => clearBulkSelection());
    }
    if (bulkApplyLayerBtn) {
      bulkApplyLayerBtn.addEventListener('click', () => handleBulkLayerSelection());
    }
    if (bulkLayerInput) {
      setupDropdownInput(bulkLayerInput, () => Object.keys(warstwy));
      bulkLayerInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleBulkLayerSelection();
        }
      });
    }

    function resolveLayerInfo(layerValue, layerIdValue) {
      const idFromValue = layerValue && layerNamesById[layerValue] ? layerValue : null;
      const idFromName = layerValue && layerDocs[layerValue] ? layerDocs[layerValue] : null;
      const resolvedId = layerIdValue || idFromValue || idFromName || null;
      let resolvedName = layerValue || 'Inne';
      if (resolvedId && layerNamesById[resolvedId]) {
        resolvedName = layerNamesById[resolvedId];
      } else if (!layerValue) {
        resolvedName = 'Inne';
      }
      return { warstwaId: resolvedId, warstwaName: resolvedName };
    }

    function applySearchFilter() {
      const query = currentSearchTerm;
      Object.values(layerDomRefs).forEach(info => {
        if (!info || !info.label) return;
        const items = info.items || [];
        let visibleCount = 0;
        items.forEach(el => {
          const match = !query || el.textContent.toLowerCase().includes(query);
          el.style.display = match ? 'block' : 'none';
          if (match) visibleCount++;
        });
        const countToShow = query ? visibleCount : info.totalCount;
        info.label.textContent = `${info.name} (${countToShow})`;
      });
    }

    const searchInput = document.getElementById('wyszukiwarka');
    if (searchInput) {
      searchInput.addEventListener('input', e => {
        currentSearchTerm = e.target.value.trim().toLowerCase();
        applySearchFilter();
      });
    }
    const greenIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
      shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    const undoStack = [];
    const redoStack = [];
    function addHistoryEntry(desc) {
      const log = document.getElementById('history-log');
      if (!log || !desc) return;
      const div = document.createElement('div');
      div.textContent = desc;
      log.appendChild(div);
      log.scrollTop = log.scrollHeight;
    }
    function removeLastHistoryEntry() {
      const log = document.getElementById('history-log');
      if (!log) return;
      if (log.lastChild) log.removeChild(log.lastChild);
    }
    function pushAction(action, description) {
      action.description = description;
      undoStack.push(action);
      redoStack.length = 0;
      addHistoryEntry(description);
    }
    function undo() {
      const action = undoStack.pop();
      if (action) {
        action.undo();
        redoStack.push(action);
        removeLastHistoryEntry();
      }
    }
    function redo() {
      const action = redoStack.pop();
      if (action) {
        action.redo();
        undoStack.push(action);
        addHistoryEntry(action.description);
      }
    }
    if (undoBtn) undoBtn.addEventListener('click', undo);
    if (redoBtn) redoBtn.addEventListener('click', redo);
    const sortSelect = document.getElementById('sortowanie');
    sortSelect.addEventListener('change', () => {
      sortMode = sortSelect.value;
      generujListeWarstw();
    });

    const toggleLayersBtn = document.getElementById("toggleLayers");
    const sidebarEl = document.getElementById("sidebar");
    if (toggleLayersBtn && sidebarEl) {
      toggleLayersBtn.addEventListener("click", () => {
        sidebarEl.classList.toggle("show");
      });
    }
    const toggleBasemapsBtn = document.getElementById("toggleBasemaps");
    const basemapSwitcherEl = document.getElementById("basemap-switcher");
    if (toggleBasemapsBtn && basemapSwitcherEl) {
      toggleBasemapsBtn.addEventListener("click", () => {
        basemapSwitcherEl.classList.toggle("show");
      });
    }
    const addLayerBtn = document.getElementById('addLayerBtn');
    const newLayerControls = document.getElementById('newLayerControls');
    const newLayerInput = document.getElementById('newLayerInput');
    const cancelNewLayerBtn = document.getElementById('cancelNewLayer');
    const importKmlBtn = document.getElementById('importKmlBtn');
    const importKmlInput = document.getElementById('importKmlInput');
    const collapseAllBtn = document.getElementById('collapseAllLayers');
    const toggleVisibilityBtn = document.getElementById('toggleVisibility');
    let allLayersCollapsed = true;
    let allLayersVisible = true;
    const hideNewLayerControls = () => {
      if (!newLayerControls) return;
      newLayerControls.style.display = 'none';
      if (newLayerInput) newLayerInput.value = '';
      if (importKmlInput) importKmlInput.value = '';
    };
    const showNewLayerControls = () => {
      if (!newLayerControls) return;
      newLayerControls.style.display = 'block';
      if (newLayerInput) newLayerInput.focus();
    };
    const ensureLayerExists = (name) => {
      if (!name) return false;
      if (!warstwy[name]) addLayer(name);
      return true;
    };
    const parseKmlContent = (content) => {
      const parser = new DOMParser();
      const xml = parser.parseFromString(content, 'application/xml');
      if (xml.querySelector('parsererror')) {
        throw new Error('Nieprawid≈Çowy plik KML');
      }
      const docNameEl = xml.querySelector('Document > name') || xml.querySelector('Folder > name');
      const layerName = docNameEl ? docNameEl.textContent.trim() : '';
      const placemarks = Array.from(xml.getElementsByTagName('Placemark'));
      const pins = placemarks.map((placemark, idx) => {
        const coordsEl = placemark.querySelector('Point > coordinates');
        if (!coordsEl) return null;
        const coords = coordsEl.textContent.trim().split(/\s+/)[0] || '';
        const [lngRaw, latRaw] = coords.split(',');
        const lat = parseFloat(latRaw);
        const lng = parseFloat(lngRaw);
        if (Number.isNaN(lat) || Number.isNaN(lng)) return null;
        const name = (placemark.querySelector('name')?.textContent || '').trim();
        const desc = (placemark.querySelector('description')?.textContent || '').trim();
        return {
          nazwa: name || `Pinezka ${idx + 1}`,
          opis: desc,
          lat,
          lng
        };
      }).filter(Boolean);
      return { layerName, pins };
    };
    const addImportedPinsToMap = async (pins, layerName) => {
      const createdPins = pins.map(pin => {
        const id = crypto.randomUUID();
        const data = {
          id,
          IDpinezki: id,
          nazwa: pin.nazwa,
          opis: pin.opis ? pin.opis.replace(/\n/g, '<br>') : '',
          warstwa: layerName,
          kategoria: '',
          emoji: '',
          nieaktywne: false,
          zamkniete: false,
          tajne: false,
          doSprawdzenia: false,
          zdewastowane: false,
          zwiedzone: false,
          wyroznione: false,
          odKogo: '',
          lat: pin.lat,
          lng: pin.lng,
          dataDodania: Date.now(),
          trasy: [],
          plany: []
        };
        data.slug = slugify(data.nazwa);
        if (!photosMap[data.slug]) {
          storePhotos(data.slug, []);
        }
        categories.add(data.kategoria || '');
        data.warstwaId = layerDocs[layerName] || null;
        if (!warstwy[layerName]) {
          warstwy[layerName] = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', loaded: true, loading: false, defaultVisible: true };
        }
        const iconEmoji = warstwy[layerName].emoji || data.emoji;
        const marker = L.marker([data.lat, data.lng], { icon: createEmojiIcon(iconEmoji, data.warstwaId, 32, data) }).addTo(warstwy[layerName].layer);
        const popupDiv = document.createElement("div");
        popupDiv.className = "popup-container";
        popupDiv.innerHTML = createPopupHtml(data);
        marker.bindPopup(popupDiv);
        attachPopupHandlers(marker, data);
        attachMarkerLongPress(marker, data);
        attachHighlight(marker, null);
        data.marker = marker;
        applyInactiveStyle(data);
        warstwy[layerName].lista.push(data);
        warstwy[layerName].loaded = true;
        wszystkiePinezki.push(data);
        return data;
      });
      generujListeWarstw();
      const savePromises = createdPins.map(async p => {
        const suffix = generateSuffix();
        const firebaseId = `${sanitize(p.nazwa)}_${suffix}`;
        p.firebaseId = firebaseId;
        const layerInfo = resolveLayerInfo(p.warstwa, p.warstwaId);
        const payload = {
          nazwa: p.nazwa,
          opis: p.opis,
          warstwa: layerInfo.warstwaId || null,
          warstwaId: layerInfo.warstwaId || null,
          kategoria: p.kategoria,
          emoji: p.emoji,
          nieaktywne: p.nieaktywne || false,
          zamkniete: p.zamkniete || false,
          tajne: p.tajne || false,
          doSprawdzenia: p.doSprawdzenia || false,
          zdewastowane: p.zdewastowane || false,
          zwiedzone: p.zwiedzone || false,
          wyroznione: p.wyroznione || false,
          lat: p.lat,
          lng: p.lng,
          dataDodania: firebase.firestore.FieldValue.serverTimestamp(),
          IDpinezki: p.id,
          odKogo: p.odKogo || '',
          trasy: [],
          plany: []
        };
        await db.collection('pinezki2').doc(firebaseId).set(payload);
      });
      await Promise.all(savePromises);
      return createdPins.length;
    };
    if (addLayerBtn && newLayerControls && newLayerInput) {
      addLayerBtn.addEventListener('click', () => {
        showNewLayerControls();
      });
      newLayerInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          const name = e.target.value.trim();
          if (ensureLayerExists(name)) {
            e.target.value = '';
            hideNewLayerControls();
          }
        } else if (e.key === 'Escape') {
          hideNewLayerControls();
        }
      });
    }
    if (cancelNewLayerBtn) {
      cancelNewLayerBtn.addEventListener('click', () => {
        hideNewLayerControls();
      });
    }
    if (importKmlBtn && importKmlInput) {
      importKmlBtn.addEventListener('click', () => {
        importKmlInput.click();
      });
      importKmlInput.addEventListener('change', async (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        try {
          const content = await file.text();
          const { layerName, pins } = parseKmlContent(content);
          if (!pins.length) {
            showToast('Brak pinezek do importu w pliku KML.');
            return;
          }
          if (layerName && newLayerInput && !newLayerInput.value.trim()) {
            newLayerInput.value = layerName;
          }
          const finalLayerName = (newLayerInput && newLayerInput.value.trim()) || layerName || 'Inne';
          ensureLayerExists(finalLayerName);
          const count = await addImportedPinsToMap(pins, finalLayerName);
          showToast(`Zaimportowano ${count} pinezek.`);
          hideNewLayerControls();
        } catch (err) {
          console.error('B≈ÇƒÖd importu KML', err);
          showToast('Nie uda≈Ço siƒô zaimportowaƒá pliku KML.');
        } finally {
          importKmlInput.value = '';
        }
      });
    }
    if (collapseAllBtn) {
      collapseAllBtn.addEventListener('click', () => {
        allLayersCollapsed = !allLayersCollapsed;
        Object.keys(warstwy).forEach(n => {
          warstwy[n].collapsed = allLayersCollapsed;
        });
        persistAllLayerCollapseStates();
        collapseAllBtn.textContent = allLayersCollapsed ? 'Rozwi≈Ñ wszystkie warstwy' : 'Zwi≈Ñ wszystkie warstwy';
        generujListeWarstw();
      });
    }
    if (toggleVisibilityBtn) {
      toggleVisibilityBtn.addEventListener('click', () => {
        allLayersVisible = !allLayersVisible;
        Object.keys(warstwy).forEach(n => {
          warstwy[n].visible = allLayersVisible;
          if (allLayersVisible) {
            warstwy[n].layer.addTo(map);
          } else {
            map.removeLayer(warstwy[n].layer);
          }
          if (!warstwy[n].temporary) {
            setLayerVisibilityState(n, warstwy[n].visible);
          }
        });
        toggleVisibilityBtn.textContent = allLayersVisible ? 'Ukryj wszystkie warstwy' : 'Poka≈º wszystkie warstwy';
        persistAllLayerVisibilityStates();
        generujListeWarstw();
      });
    }

    function hasUnsavedChanges() {
      const layerChanges =
        layersToAdd.length > 0 ||
        layersToDelete.length > 0 ||
        layerOrderChanged ||
        Object.keys(layerEmojiChanges).length > 0 ||
        Object.keys(layerDefaultVisibilityChanges).length > 0;
      const routeChanges = window.localTrasy.length > 0;
      return (
        Object.keys(zmianyDoZapisania).length > 0 ||
        nowePinezki.length > 0 ||
        layerChanges ||
        routeChanges
      );
    }

    function updateSaveButton() {
      const pending = hasUnsavedChanges();
      shouldWarnBeforeUnload = pending;
      const btn = document.getElementById('saveChanges');
      if (!btn) return;
      btn.style.display = pending ? 'block' : 'none';
      btn.classList.toggle('unsaved', pending);
    }

    function markPinUnsaved(slug) {
      const p = wszystkiePinezki.find(pp => pp.slug === slug);
      if (p) {
        p.unsaved = true;
        if (!zmianyDoZapisania[p.id]) zmianyDoZapisania[p.id] = {};
      }
      updateSaveButton();
    }
    function selectTool(t) {
      currentTool = t;
      handBtn.classList.toggle("active", t === "hand");
      pinBtn.classList.toggle("active", t === "pin");
      if (mapEl) {
        if (t === "pin") {
          mapEl.classList.add("pin-cursor");
        } else {
          mapEl.classList.remove("pin-cursor");
        }
      }
      const cm = document.getElementById('centerMarker');
      if (cm) {
        if (t === 'pin' && window.innerWidth <= 800) {
          cm.style.display = 'block';
        } else {
          cm.style.display = 'none';
        }
      }
    }
    if (handBtn) handBtn.addEventListener("click", () => selectTool("hand"));
if (pinBtn) pinBtn.addEventListener("click", () => selectTool("pin"));
    selectTool("hand");

    window.addEventListener('beforeunload', e => {
      if (hasUnsavedChanges()) {
        e.preventDefault();
        e.returnValue = 'Masz niezapisane zmiany. Czy na pewno chcesz wyj≈õƒá?';
      }
    });

    function sanitizeOpis(text) {
      if (!text) return '';
      return text
        .replace(/<img[^>]*mymaps\.usercontent[^>]*>/gi, '')
        .replace(/https?:\/\/mymaps\.usercontent\.google\.com[^"'\s><]*/gi, '')
        .replace(/mymaps\.usercontent\.google\.com[^"'\s><]*/gi, '')
        .replace(/\s*height\s*=\s*['"]?200['"]?\s*width\s*=\s*['"]?auto['"]?\s*\/?\s*>?/gi, '')
        .replace(/\bsrc\s*=\s*['"][^"']*mymaps\.usercontent[^"']*['"]/gi, '')
        .replace(/\s{2,}/g, ' ')
        .trim();
    }

    function linkify(text) {
      const cleaned = sanitizeOpis(text);
      if (!cleaned) return '';
      const urlRegex = /(https?:\/\/[^\s]+|www\.[^\s]+)/g;
      return cleaned
        .replace(urlRegex, url => {
          const href = url.startsWith('http') ? url : `https://${url}`;
          let display;
          try {
            display = new URL(href).hostname.replace(/^www\./, '');
          } catch (e) {
            display = url;
          }
          return `<a href="${href}" target="_blank">${display}</a>`;
        })
        .replace(/\n/g, '<br>');
    }

    function formatCoords(lat, lng) {
      return `${Number(lat).toFixed(5)}, ${Number(lng).toFixed(5)}`;
    }

    function resolveAddress(lat, lng) {
      const key = `${Number(lat).toFixed(6)},${Number(lng).toFixed(6)}`;
      if (addressCache.has(key)) {
        return Promise.resolve(addressCache.get(key));
      }
      if (addressPromises.has(key)) {
        return addressPromises.get(key);
      }

      const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&accept-language=pl`;
      const request = fetch(url)
        .then(resp => {
          if (!resp.ok) {
            throw new Error(`Reverse geocoding error: ${resp.status}`);
          }
          return resp.json();
        })
        .then(data => {
          const address = data && data.address ? data.address : {};
          const locality = address.city || address.town || address.village || address.municipality || address.hamlet || address.locality;
          const road = address.road || address.pedestrian || address.footway || address.path || address.cycleway || address.residential;
          const houseNumber = address.house_number || address.house;
          let formatted = '';
          if (road && houseNumber && locality) {
            formatted = `${locality}, ${road} ${houseNumber}`;
          } else if (road && locality) {
            formatted = `${locality}, ${road}`;
          } else if (locality) {
            formatted = locality;
          } else if (data && data.display_name) {
            const segments = data.display_name.split(',').map(s => s.trim()).filter(Boolean);
            formatted = segments.slice(0, 3).join(', ');
          }
          addressCache.set(key, formatted || null);
          return formatted || null;
        })
        .catch(err => {
          console.error('Failed to fetch address', err);
          addressCache.set(key, null);
          return null;
        })
        .finally(() => {
          addressPromises.delete(key);
        });

      addressPromises.set(key, request);
      return request;
    }

    function updatePopupAddress(container, lat, lng) {
      const el = container ? container.querySelector('.popup-address') : null;
      if (!el) return;
      const targetLat = lat ?? parseFloat(el.dataset.lat);
      const targetLng = lng ?? parseFloat(el.dataset.lng);
      if (!Number.isFinite(targetLat) || !Number.isFinite(targetLng)) {
        el.textContent = 'Adres: brak danych';
        return;
      }

      el.textContent = 'Adres: wyszukiwanie...';
      resolveAddress(targetLat, targetLng).then(result => {
        el.textContent = result ? `Adres: ${result}` : 'Adres: brak danych';
      });
    }

    function formatDate(ts) {
      if (!ts) return 'brak daty';
      try {
        const d = new Date(ts);
        if (isNaN(d)) return 'brak daty';
        return d.toLocaleDateString('pl-PL');
      } catch (e) {
        return 'brak daty';
      }
    }

    function trudnoscText(val) {
      switch (parseInt(val, 10)) {
        case 0: return 'Nieznany';
        case 1: return 'Bardzo ≈Çatwy';
        case 2: return '≈Åatwy';
        case 3: return '≈öredni';
        case 4: return 'Trudny';
        case 5: return 'Bardzo trudny';
        default: return 'Nieznany';
      }
    }

    function trudnoscColor(val) {
      switch (parseInt(val, 10)) {
        case 0: return '#555555';
        case 1: return 'green';
        case 2: return 'limegreen';
        case 3: return 'yellow';
        case 4: return 'orange';
        case 5: return 'red';
        default: return '#555555';
      }
    }

    function createEmojiIcon(emojiOrUrl, warstwaId, size = 32, status = {}) {
      emojiOrUrl = resolveEmoji(emojiOrUrl);
      const markerScale = 0.8;
      const scaledSize = size * markerScale;
      const overlaySize = (20 * markerScale).toFixed(1);
      const imageSize = (28 * markerScale).toFixed(1);
      const isVisitedLayer = warstwaId && warstwaId === visitedId;
      const isSztosy = warstwaId && warstwaId === sztosyId;
      const isHighlighted = isSztosy || status.wyroznione;
      if (warstwaId && warstwaId === orangeLayerId) {
        return L.icon({
          iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/orange-dot.png',
          iconSize: [scaledSize, scaledSize],
          iconAnchor: [scaledSize / 2, scaledSize]
        });
      }
      if (warstwaId && warstwaId === movingLayerId) {
        return L.icon({
          iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/blue-dot.png',
          iconSize: [scaledSize, scaledSize],
          iconAnchor: [scaledSize / 2, scaledSize]
        });
      }

      if (!emojiOrUrl || String(emojiOrUrl).trim() === "" || emojiOrUrl === "undefined") {
        return L.icon({
          iconUrl: 'https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png',
          iconSize: [scaledSize * 0.56, scaledSize * 0.9],
          iconAnchor: [scaledSize * 0.28, scaledSize * 0.9]
        });
      }

      const isUrl = emojiOrUrl && emojiOrUrl.startsWith("http");
      const statusClass = isHighlighted ? 'status-icon sztosy' : 'status-icon';
      const statusIcon = (status.nieaktywne || status.niedostepne)
        ? `<span class="${statusClass}">‚õî</span>`
        : status.zamkniete
          ? `<span class="${statusClass}">üîê</span>`
          : status.tajne
            ? `<span class="${statusClass}">ü§´</span>`
            : status.doSprawdzenia
              ? `<span class="${statusClass}">‚ùî</span>`
              : status.zdewastowane
                ? `<span class="${statusClass}">üí•</span>`
                : (status.zwiedzone || isVisitedLayer)
                  ? `<img src="https://upload.wikimedia.org/wikipedia/commons/0/03/Green_check.svg" width="${overlaySize}" height="${overlaySize}" class="${statusClass} checkmark-obrys">`
                : '';
      const overlay = `${isHighlighted ? '<span class="sztosy-gwiazda">‚≠ê</span>' : ''}${statusIcon}`;

      if (isUrl) {
        const cls = isHighlighted ? "emoji-obrys-sztosy" : "emoji-obrys";
        return L.divIcon({
          className: 'emoji-marker',
          html: `
            <div style="position: relative; display: inline-block;">
              <img src="${emojiOrUrl}" class="${cls}" width="${imageSize}" height="${imageSize}">
              ${overlay}
            </div>`,
          iconSize: [scaledSize, scaledSize],
          iconAnchor: [scaledSize / 2, scaledSize]
        });
      }

      const cls = isHighlighted ? "emoji-sztosy" : "";

      return L.divIcon({
        className: 'emoji-marker',
        html: `
          <div style="position: relative; display: inline-block;">
            <span class="${cls}">${emojiOrUrl}</span>
            ${overlay}
          </div>`,
        iconSize: [scaledSize, scaledSize],
        iconAnchor: [scaledSize / 2, scaledSize]
      });
    }


function emojiHtml(str) {
  if (!str) return '';
  const url = resolveEmoji(str);
  if (url.startsWith('http')) {
    return `<span class="hidden-text">${str} </span><img src="${url}" class="emoji-inline">`;
  }
  return url;
}


    function getStoredPhotos(slug) {
      return (photosMap[slug] || []).slice();
    }

    function storePhotos(slug, arr) {
      photosMap[slug] = arr;
    }

    function renderGallery(gallery) {
      if (!gallery) return;
      const slug = gallery.dataset.slug;
      const photos = getStoredPhotos(slug);
      gallery.innerHTML = '';
      if (photos.length === 0) return;
      photos.forEach((ph, idx) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'photo-item';
        const img = imgWithFallback(ph.url);
        img.dataset.index = idx;
        img.className = 'popup-photo';
        const del = document.createElement('span');
        del.className = 'photo-delete';
        del.dataset.index = idx;
        del.textContent = 'üóëÔ∏è';
        wrapper.appendChild(img);
        wrapper.appendChild(del);
        gallery.appendChild(wrapper);
      });
      adjustGalleryLayout(gallery);
    }

    function adjustGalleryLayout(gallery) {
      const items = gallery.querySelectorAll('.photo-item');
      const count = items.length;
      items.forEach(item => {
        if (count === 1) {
          item.style.width = '100%';
        } else if (count === 2) {
          item.style.width = 'calc((100% - 2px) / 2)';
        } else {
          item.style.width = 'calc((100% - 4px) / 3)';
        }
      });
    }

    function setupGallery(gallery) {
      if (!gallery) return;
      renderGallery(gallery);
      gallery.addEventListener('click', e => {
        if (e.target.classList.contains('photo-delete')) {
          e.stopPropagation();
          const slug = gallery.dataset.slug;
          const idx = parseInt(e.target.dataset.index);
          const photos = getStoredPhotos(slug);
          photos.splice(idx, 1);
          storePhotos(slug, photos);
          renderGallery(gallery);
          markPinUnsaved(slug);
          updateSaveButton();
        } else if (e.target.tagName === 'IMG') {
          openPhotoModal(gallery.dataset.slug, parseInt(e.target.dataset.index));
        }
      });
    }

    function addPhotosToSlug(slug, files, gallery) {
      if (!files || files.length === 0) return;
      const existing = getStoredPhotos(slug);
      let idx = 0;
      function next() {
        if (idx >= files.length) {
          storePhotos(slug, existing);
          if (gallery) {
            renderGallery(gallery);
          }
          markPinUnsaved(slug);
          updateSaveButton();
          return;
        }
        const file = files[idx]; // [CODEx CHANGED] usuniƒôty limit rozmiaru 1 MB
        const reader = new FileReader();
        reader.onload = e => {
          existing.push({url: e.target.result});
          idx++;
          next();
        };
        reader.readAsDataURL(file);
      }
      next();
    }

    function setupAddPhotoButton(btn, slug, gallery) {
      if (!btn) return;
      btn.addEventListener('click', e => {
        e.stopPropagation();
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.multiple = true;
        input.addEventListener('change', () => {
          addPhotosToSlug(slug, Array.from(input.files || []), gallery);
        });
        input.click();
      });
    }

    function ensurePlanDefaults(plan, pin) {
      if (!plan) return null;
      if (!plan.id) plan.id = 'plan_' + Date.now() + '_' + Math.random().toString(36).slice(2, 7);
      if (!plan.pozycja) {
        const pos = pin ? L.latLng(pin.lat, pin.lng) : map.getCenter();
        plan.pozycja = { lat: pos.lat, lng: pos.lng };
      }
      if (!plan.szerokosc) plan.szerokosc = 120;
      if (!plan.wysokosc) plan.wysokosc = plan.szerokosc;
      if (!plan.proporcja) plan.proporcja = plan.szerokosc && plan.wysokosc ? (plan.szerokosc / plan.wysokosc) : 1;
      if (!plan.bazowaSzerokosc) plan.bazowaSzerokosc = plan.szerokosc;
      if (!plan.skala) plan.skala = 100;
      if (plan.przezroczystosc === undefined || plan.przezroczystosc === null) plan.przezroczystosc = 1;
      if (plan.widoczny === undefined) plan.widoczny = true;
      if (plan.obrot === undefined || plan.obrot === null) plan.obrot = 0;
      if (!plan.nazwa) {
        const total = pin && pin.plany ? pin.plany.length : 0;
        plan.nazwa = `Plan ${total + 1}`;
      }
      return plan;
    }

    function getPlanBounds(plan) {
      const center = L.latLng(plan.pozycja.lat, plan.pozycja.lng);
      const halfWm = (plan.szerokosc || 120) / 2;
      const ratio = plan.proporcja || 1;
      const halfHm = (plan.wysokosc || (plan.szerokosc || 120) / (ratio || 1)) / 2;
      const latDelta = halfHm / 111320;
      const lngDelta = halfWm / (111320 * Math.cos(center.lat * Math.PI / 180));
      return L.latLngBounds([
        [center.lat - latDelta, center.lng - lngDelta],
        [center.lat + latDelta, center.lng + lngDelta]
      ]);
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function syncPlanTransformOverlay(overlay) {
      if (!overlay || !overlay._image || !overlay._planControls) return;
      const img = overlay._image;
      const ctrl = overlay._planControls;
      ctrl.style.width = img.style.width || `${img.offsetWidth}px`;
      ctrl.style.height = img.style.height || `${img.offsetHeight}px`;
      ctrl.style.transformOrigin = img.style.transformOrigin || 'center center';
      ctrl.style.transform = img.style.transform;
    }

    function applyPlanRotation(overlay, plan) {
      if (!overlay || !overlay._image) return;
      const img = overlay._image;
      const base = img.style.transform || '';
      const cleaned = base.replace(/ rotate\([^)]*\)/, '');
      img.style.transform = `${cleaned} rotate(${(plan && plan.obrot) || 0}deg)`;
      img.style.transformOrigin = 'center center';
      syncPlanTransformOverlay(overlay);
    }

    function shouldPlanBeVisible(pin, plan) {
      if (activePlanPlacement && activePlanPlacement.plan === plan) return true;
      const layerVisible = pin && pin.warstwa && warstwy[pin.warstwa] ? warstwy[pin.warstwa].visible !== false : true;
      const pinVisible = (selectedCategories.size === 0 || selectedCategories.has(pin.kategoria || '')) && pinMatchesStatus(pin);
      return (plan.widoczny !== false) && layerVisible && pinVisible;
    }

    function ensurePlanOverlay(pin, plan) {
      ensurePlanDefaults(plan, pin);
      let overlay = planLayers[plan.id];
      const bounds = getPlanBounds(plan);
      if (!overlay) {
        overlay = L.imageOverlay(plan.url, bounds, { opacity: plan.przezroczystosc || 1, interactive: true });
        planLayers[plan.id] = overlay;
        plan.layer = overlay;
        if (!overlay._originalReset) {
          overlay._originalReset = overlay._reset.bind(overlay);
          overlay._reset = function() {
            overlay._originalReset();
            applyPlanRotation(overlay, overlay._planRef || plan);
          };
        }
      } else {
        overlay.setBounds(bounds);
        overlay.setOpacity(plan.przezroczystosc || 1);
      }
      overlay._planRef = plan;
      applyPlanRotation(overlay, plan);
      if (shouldPlanBeVisible(pin, plan)) {
        overlay.addTo(map);
      } else {
        map.removeLayer(overlay);
      }
      return overlay;
    }

    function updatePlanOverlay(pin, plan) {
      if (!plan) return;
      ensurePlanDefaults(plan, pin);
      if (!planLayers[plan.id]) return ensurePlanOverlay(pin, plan);
      const overlay = planLayers[plan.id];
      if (overlay.setUrl && overlay._url !== plan.url) {
        overlay.setUrl(plan.url);
      }
      overlay.setBounds(getPlanBounds(plan));
      overlay.setOpacity(plan.przezroczystosc || 1);
      overlay._planRef = plan;
      applyPlanRotation(overlay, plan);
      if (shouldPlanBeVisible(pin, plan)) {
        overlay.addTo(map);
      } else {
        map.removeLayer(overlay);
      }
      return overlay;
    }

    function removePlanOverlay(plan) {
      if (!plan) return;
      const overlay = planLayers[plan.id];
      if (overlay) {
        cleanupPlanTransformOverlay(overlay);
        map.removeLayer(overlay);
        delete planLayers[plan.id];
      }
      delete plan.layer;
    }

    function updatePlanVisibilityForPin(pin) {
      if (!pin || !pin.plany) return;
      pin.plany.forEach(pl => updatePlanOverlay(pin, pl));
    }

    function cleanupPlanTransformOverlay(overlay) {
      if (!overlay) return;
      if (overlay._planTransformRefresh) {
        map.off('zoom', overlay._planTransformRefresh);
        map.off('move', overlay._planTransformRefresh);
        map.off('resize', overlay._planTransformRefresh);
        overlay._planTransformRefresh = null;
      }
      if (overlay._planControls && overlay._planControls.parentElement) {
        overlay._planControls.parentElement.removeChild(overlay._planControls);
      }
      overlay._planControls = null;
    }

    function destroyPlanTransformControls() {
      document.removeEventListener('mousemove', onPlanPointerMove);
      document.removeEventListener('mouseup', stopPlanPointerInteraction);
      if (map && map.dragging) map.dragging.enable();
      planTransformState = null;
      if (activePlanPlacement && activePlanPlacement.plan && activePlanPlacement.plan.layer) {
        cleanupPlanTransformOverlay(activePlanPlacement.plan.layer);
      }
    }

    function startPlanMove(e, overlay) {
      if (!activePlanPlacement || e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      const plan = activePlanPlacement.plan;
      planTransformState = {
        mode: 'move',
        overlay,
        startMouse: { x: e.clientX, y: e.clientY },
        startPoint: map.latLngToContainerPoint(plan.pozycja)
      };
      if (overlay && overlay._image) overlay._image.style.cursor = 'grabbing';
      if (map && map.dragging) map.dragging.disable();
      document.addEventListener('mousemove', onPlanPointerMove);
      document.addEventListener('mouseup', stopPlanPointerInteraction);
    }

    function startPlanScale(e, overlay, corner) {
      if (!activePlanPlacement || e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      const rect = overlay._image.getBoundingClientRect();
      const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      const startVec = { x: e.clientX - center.x, y: e.clientY - center.y };
      const startDist = Math.hypot(startVec.x, startVec.y) || 1;
      const plan = activePlanPlacement.plan;
      planTransformState = {
        mode: 'scale',
        overlay,
        center,
        startDist,
        startScale: plan.skala || 100,
        startWidth: plan.szerokosc || 120,
        corner
      };
      if (map && map.dragging) map.dragging.disable();
      document.addEventListener('mousemove', onPlanPointerMove);
      document.addEventListener('mouseup', stopPlanPointerInteraction);
    }

    function startPlanRotate(e, overlay) {
      if (!activePlanPlacement || e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      const rect = overlay._image.getBoundingClientRect();
      const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      const plan = activePlanPlacement.plan;
      planTransformState = {
        mode: 'rotate',
        overlay,
        center,
        startAngle: Math.atan2(e.clientY - center.y, e.clientX - center.x),
        startRotation: plan.obrot || 0
      };
      if (map && map.dragging) map.dragging.disable();
      document.addEventListener('mousemove', onPlanPointerMove);
      document.addEventListener('mouseup', stopPlanPointerInteraction);
    }

    function onPlanPointerMove(e) {
      if (!planTransformState || !activePlanPlacement) return;
      const plan = activePlanPlacement.plan;
      if (planTransformState.mode === 'move') {
        const dx = e.clientX - planTransformState.startMouse.x;
        const dy = e.clientY - planTransformState.startMouse.y;
        const newPoint = planTransformState.startPoint.add(L.point(dx, dy));
        plan.pozycja = map.containerPointToLatLng(newPoint);
      } else if (planTransformState.mode === 'scale') {
        const curVec = { x: e.clientX - planTransformState.center.x, y: e.clientY - planTransformState.center.y };
        const curDist = Math.hypot(curVec.x, curVec.y) || 1;
        const factor = clamp(curDist / planTransformState.startDist, 0.25, 3);
        const newScale = clamp(Math.round((planTransformState.startScale || 100) * factor), 25, 300);
        plan.skala = newScale;
        plan.szerokosc = (plan.bazowaSzerokosc || planTransformState.startWidth) * (plan.skala / 100);
        plan.wysokosc = plan.szerokosc / (plan.proporcja || 1);
      } else if (planTransformState.mode === 'rotate') {
        const angle = Math.atan2(e.clientY - planTransformState.center.y, e.clientX - planTransformState.center.x);
        const delta = (angle - planTransformState.startAngle) * 180 / Math.PI;
        let rotation = planTransformState.startRotation + delta;
        rotation = ((rotation % 360) + 360) % 360;
        plan.obrot = rotation;
      }
      plan.unsaved = true;
      updatePlanOverlay(activePlanPlacement.pin, plan);
      ensurePlanTransformControls(activePlanPlacement.pin, plan);
    }

    function stopPlanPointerInteraction() {
      document.removeEventListener('mousemove', onPlanPointerMove);
      document.removeEventListener('mouseup', stopPlanPointerInteraction);
      if (map && map.dragging) map.dragging.enable();
      if (planTransformState && planTransformState.overlay && planTransformState.overlay._image) {
        planTransformState.overlay._image.style.cursor = 'grab';
      }
      planTransformState = null;
    }

    function ensurePlanTransformControls(pin, plan) {
      if (!activePlanPlacement || activePlanPlacement.plan !== plan) return;
      const overlay = ensurePlanOverlay(pin, plan);
      if (!overlay || !overlay._image) return;
      overlay._planRef = plan;
      if (!overlay._planControls) {
        const ctrl = document.createElement('div');
        ctrl.className = 'plan-transform-overlay';
        ctrl.style.pointerEvents = 'none';
        const corners = ['nw', 'ne', 'sw', 'se'];
        corners.forEach(corner => {
          const handle = document.createElement('div');
          handle.className = `plan-handle ${corner}`;
          handle.addEventListener('mousedown', ev => startPlanScale(ev, overlay, corner));
          ctrl.appendChild(handle);
          const rot = document.createElement('div');
          rot.className = 'plan-rotate';
          if (corner.includes('n')) rot.style.top = '-26px'; else rot.style.bottom = '-26px';
          if (corner.includes('w')) rot.style.left = '-26px'; else rot.style.right = '-26px';
          rot.addEventListener('mousedown', ev => startPlanRotate(ev, overlay));
          ctrl.appendChild(rot);
        });
        overlay._planControls = ctrl;
        if (overlay._image.parentElement) overlay._image.parentElement.appendChild(ctrl);
        overlay._planTransformRefresh = () => syncPlanTransformOverlay(overlay);
        map.on('zoom', overlay._planTransformRefresh);
        map.on('move', overlay._planTransformRefresh);
        map.on('resize', overlay._planTransformRefresh);
      }
      if (!overlay._planMoveBound) {
        overlay._image.addEventListener('mousedown', ev => startPlanMove(ev, overlay));
        overlay._planMoveBound = true;
      }
      overlay._image.style.cursor = 'grab';
      syncPlanTransformOverlay(overlay);
    }

    function markPlanChange(pin) {
      markPinUnsaved(pin.slug);
      zmianyDoZapisania[pin.id] = Object.assign(zmianyDoZapisania[pin.id] || {}, { plany: serializePlans(pin) });
      updateSaveButton();
    }

    function serializePlans(pin) {
      return (pin.plany || []).map(pl => {
        const copy = { ...pl };
        ensurePlanDefaults(copy, pin);
        return {
          id: copy.id,
          nazwa: copy.nazwa,
          url: copy.url,
          path: copy.path || null,
          pozycja: copy.pozycja,
          szerokosc: copy.szerokosc,
          wysokosc: copy.wysokosc,
          proporcja: copy.proporcja,
          bazowaSzerokosc: copy.bazowaSzerokosc,
          skala: copy.skala,
          przezroczystosc: copy.przezroczystosc,
          obrot: copy.obrot || 0,
          widoczny: copy.widoczny !== false
        };
      });
    }

    function clonePlanWithoutRuntime(plan) {
      if (!plan) return null;
      const plain = { ...plan };
      delete plain.layer;
      delete plain._planRef;
      return JSON.parse(JSON.stringify(plain));
    }

    function openPlanEditor(pin, plan, mode = 'new') {
      const editor = document.getElementById('planEditor');
      if (!editor) return;
      destroyPlanTransformControls();
      ensurePlanDefaults(plan, pin);
      activePlanPlacement = { pin, plan, mode, original: mode === 'edit' ? clonePlanWithoutRuntime(plan) : null };
      ensurePlanOverlay(pin, plan);
      ensurePlanTransformControls(pin, plan);
      const nameInput = document.getElementById('planNameInput');
      const scaleInput = document.getElementById('planScale');
      const opacityInput = document.getElementById('planOpacity');
      if (nameInput) nameInput.value = plan.nazwa || '';
      if (scaleInput) scaleInput.value = plan.skala || 100;
      if (opacityInput) opacityInput.value = Math.round((plan.przezroczystosc || 1) * 100);
      editor.style.display = 'block';
    }

    function closePlanEditor(cancelled = false) {
      const editor = document.getElementById('planEditor');
      if (!editor) return;
      editor.style.display = 'none';
      destroyPlanTransformControls();
      if (activePlanPlacement && cancelled) {
        if (activePlanPlacement.mode === 'new') {
          removePlanOverlay(activePlanPlacement.plan);
        } else if (activePlanPlacement.original) {
          Object.assign(activePlanPlacement.plan, activePlanPlacement.original);
          updatePlanOverlay(activePlanPlacement.pin, activePlanPlacement.plan);
        }
      }
      activePlanPlacement = null;
    }

    function planScaleChanged(value) {
      if (!activePlanPlacement) return;
      const plan = activePlanPlacement.plan;
      plan.skala = parseInt(value, 10) || 100;
      plan.szerokosc = (plan.bazowaSzerokosc || plan.szerokosc) * (plan.skala / 100);
      plan.wysokosc = plan.szerokosc / (plan.proporcja || 1);
      updatePlanOverlay(activePlanPlacement.pin, plan);
    }

    function planOpacityChanged(value) {
      if (!activePlanPlacement) return;
      const plan = activePlanPlacement.plan;
      plan.przezroczystosc = (parseInt(value, 10) || 100) / 100;
      updatePlanOverlay(activePlanPlacement.pin, plan);
    }

      function confirmPlanPlacement() {
        if (!activePlanPlacement) return;
        const { pin, plan, mode } = activePlanPlacement;
        ensurePlanDefaults(plan, pin);
        const nameInput = document.getElementById('planNameInput');
        if (nameInput && nameInput.value.trim()) plan.nazwa = nameInput.value.trim();
        if (!pin.plany) pin.plany = [];
        if (mode === 'new') {
          pin.plany.push(plan);
        }
        plan.unsaved = true;
        updatePlanOverlay(pin, plan);
        markPlanChange(pin);
        closePlanEditor(false);
        generujListeWarstw();
      }

      function pickPlanImageFile(onLoad) {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.addEventListener('change', () => {
          const file = input.files && input.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = ev => {
            const dataUrl = ev.target.result;
            const img = new Image();
            img.onload = () => onLoad(dataUrl, img);
            img.src = dataUrl;
          };
          reader.readAsDataURL(file);
        });
        input.click();
      }

      function startPlanUpload(pin) {
        pickPlanImageFile((dataUrl, img) => {
          const plan = {
            url: dataUrl,
            szerokosc: 140,
            wysokosc: 140 * (img.height ? img.height / img.width : 1),
            proporcja: img.width ? img.width / img.height : 1,
            bazowaSzerokosc: 140,
            skala: 100,
            przezroczystosc: 0.8
          };
          ensurePlanDefaults(plan, pin);
          openPlanEditor(pin, plan, 'new');
        });
      }

      function changeActivePlanImage(targetPin = null, targetPlan = null) {
        const context = activePlanPlacement || (targetPin && targetPlan ? { pin: targetPin, plan: targetPlan } : null);
        if (!context) return;
        const { pin, plan } = context;
        const baseWidth = plan.bazowaSzerokosc || (plan.szerokosc ? plan.szerokosc * 100 / (plan.skala || 100) : 140);
        const scale = plan.skala || 100;

        pickPlanImageFile((dataUrl, img) => {
          plan.url = dataUrl;
          plan.proporcja = img.width ? img.width / img.height : 1;
          plan.bazowaSzerokosc = baseWidth;
          plan.skala = scale;
          plan.szerokosc = (plan.bazowaSzerokosc || baseWidth) * (plan.skala / 100);
          plan.wysokosc = plan.szerokosc / (plan.proporcja || 1);
          plan.unsaved = true;
          updatePlanOverlay(pin, plan);
          ensurePlanTransformControls(pin, plan);
          markPlanChange(pin);
        });
      }

    function openPlanOptions(pin, plan, anchor) {
      const panel = document.getElementById('planOptions');
      if (!panel) return;
      planOptionsState = { pin, plan };
      panel.innerHTML = '';
      const rect = anchor.getBoundingClientRect();
      panel.style.top = `${rect.bottom + window.scrollY + 6}px`;
      panel.style.left = `${rect.left + window.scrollX}px`;
      const title = document.createElement('h4');
      title.textContent = 'Plan';
      const nameRow = document.createElement('div');
      nameRow.className = 'row';
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = plan.nazwa || '';
      nameInput.addEventListener('input', () => {
        plan.nazwa = nameInput.value;
        plan.unsaved = true;
        generujListeWarstw();
        markPlanChange(pin);
      });
      nameRow.appendChild(nameInput);

      const opacityRow = document.createElement('div');
      opacityRow.className = 'row';
      const opLabel = document.createElement('label');
      opLabel.textContent = 'Przezroczysto≈õƒá';
      const opSlider = document.createElement('input');
      opSlider.type = 'range';
      opSlider.min = 20; opSlider.max = 100;
      opSlider.value = Math.round((plan.przezroczystosc || 1) * 100);
      opSlider.addEventListener('input', () => {
        plan.przezroczystosc = (parseInt(opSlider.value, 10) || 100) / 100;
        plan.unsaved = true;
        updatePlanOverlay(pin, plan);
        markPlanChange(pin);
      });
      opacityRow.appendChild(opLabel);
      opacityRow.appendChild(opSlider);

      const scaleRow = document.createElement('div');
      scaleRow.className = 'row';
      const scLabel = document.createElement('label');
      scLabel.textContent = 'Skala';
      const scSlider = document.createElement('input');
      scSlider.type = 'range'; scSlider.min = 25; scSlider.max = 300;
      scSlider.value = plan.skala || 100;
      scSlider.addEventListener('input', () => {
        plan.skala = parseInt(scSlider.value, 10) || 100;
        plan.szerokosc = (plan.bazowaSzerokosc || plan.szerokosc) * (plan.skala / 100);
        plan.wysokosc = plan.szerokosc / (plan.proporcja || 1);
        plan.unsaved = true;
        updatePlanOverlay(pin, plan);
        markPlanChange(pin);
      });
      scaleRow.appendChild(scLabel);
      scaleRow.appendChild(scSlider);

      const changeImgBtn = document.createElement('button');
      changeImgBtn.textContent = 'Zmie≈Ñ obraz';
      changeImgBtn.addEventListener('click', e => {
        e.stopPropagation();
        changeActivePlanImage(pin, plan);
      });

      const repositionBtn = document.createElement('button');
      repositionBtn.textContent = 'Zmie≈Ñ pozycjƒô na mapie';
      repositionBtn.addEventListener('click', e => {
        e.stopPropagation();
        panel.style.display = 'none';
        openPlanEditor(pin, plan, 'edit');
      });

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Usu≈Ñ plan';
      deleteBtn.addEventListener('click', e => {
        e.stopPropagation();
        pin.plany = (pin.plany || []).filter(pl => pl !== plan);
        removePlanOverlay(plan);
        markPlanChange(pin);
        panel.style.display = 'none';
        generujListeWarstw();
      });

      panel.appendChild(title);
      panel.appendChild(nameRow);
      panel.appendChild(opacityRow);
      panel.appendChild(scaleRow);
      panel.appendChild(changeImgBtn);
      panel.appendChild(repositionBtn);
      panel.appendChild(deleteBtn);
      panel.style.display = 'block';
    }

    document.addEventListener('click', e => {
      const panel = document.getElementById('planOptions');
      if (panel && panel.style.display === 'block' && !panel.contains(e.target)) {
        panel.style.display = 'none';
      }
    });

    function createPopupHtml(p) {
      const slug = p.slug || slugify(p.nazwa || '');
      const layerLabel = resolveLayerInfo(p.warstwa, p.warstwaId).warstwaName || 'Inne';
      const trudHtml = p.trudnosc !== undefined ?
        `<div class="trudnosc-wrapper">
          <div class="trudnosc-text" id="trudnoscLabel-${p.id}" style="color:${trudnoscColor(p.trudnosc)}">Poziom trudno≈õci: ${trudnoscText(p.trudnosc)}</div>
        </div>` : '';
      const statusHtml = `
        ${(p.niedostepne || p.nieaktywne) ? `<div style="opacity:0.8;">Niedostƒôpne ‚õî</div>` : ''}
        ${p.zamkniete ? `<div style="opacity:0.8;">Zamkniƒôte üîê</div>` : ''}
        ${p.tajne ? `<div style="opacity:0.8;">Tajne ü§´</div>` : ''}
        ${p.doSprawdzenia ? `<div style="opacity:0.8;">Do sprawdzenia ‚ùî</div>` : ''}
        ${p.zdewastowane ? `<div style="opacity:0.8;">Zdewastowane üí•</div>` : ''}
        ${p.zwiedzone ? `<div style="opacity:0.8;">Zwiedzone <img src="https://upload.wikimedia.org/wikipedia/commons/0/03/Green_check.svg" width="16" height="16" class="checkmark-obrys"></div>` : ''}
        ${p.wyroznione ? `<div style="opacity:0.8;">Wyr√≥≈ºnione ‚≠ê</div>` : ''}`;
      return `
        <div class="photo-gallery" data-slug="${slug}"></div>
        <b>${p.emoji ? emojiHtml(p.emoji) + ' ' : ''}${p.nazwa}</b>
        ${trudHtml}
        ${statusHtml}
        <div style="border-top:1px solid #444;"></div>
        <div style="height:4px;"></div>
        ${(() => {
          const sanitized = sanitizeOpis(p.opis);
          const shouldScroll = sanitized && sanitized.length > 100;
          return `<div class="popup-description${shouldScroll ? ' scrollable' : ''}">${linkify(p.opis)}</div>`;
        })()}
        <div style="height:4px;"></div>
        <div style="border-top:1px solid #444;"></div>
        <div class="popup-info-item">Warstwa: ${layerLabel}</div>
        ${p.kategoria ? `<div class="popup-info-item">Kategoria: ${p.kategoria}</div>` : ''}
        ${p.odKogo ? `<div class="popup-info-item">Od kogo: ${p.odKogo}</div>` : ''}
        <div class="popup-info-item">Data dodania: ${formatDate(p.dataDodania)}</div>
        <div class="popup-info-item popup-address" data-lat="${p.lat}" data-lng="${p.lng}">Adres: wyszukiwanie...</div>
        <div class="popup-info-item">${formatCoords(p.lat, p.lng)}</div>
        <div class="popup-info-item"><a href="https://maps.google.com/?q=${p.lat},${p.lng}" target="_blank">üìç Google Maps</a></div>
        <div class="popup-edit-row">
          <button class="popup-edit-btn" id="editBtn-${p.id}">‚úèÔ∏è</button>
        </div>
        <div class="popup-route-actions">
          <button class="popup-route-btn" id="routeBtn-${p.id}">Dodaj trasƒô</button>
          <button class="popup-direct-route-btn" id="routeDirectBtn-${p.id}">Wyznacz trasƒô do</button>
          <button class="popup-route-btn" id="planBtn-${p.id}">Dodaj plan</button>
        </div>
      `;
    }

    function attachPopupHandlers(marker, p) {
    /*  console.log('Wywo≈Çano attachPopupHandlers dla pinezki:', p); // <-- dodane */
      const handler = e => {
        const container = e.popup.getElement();
        if (!container) return;
        setupGallery(container.querySelector('.photo-gallery'));
        const btn = container.querySelector(`#editBtn-${p.id}`);
        if (btn) {
          btn.addEventListener('click', ev => {
            ev.stopPropagation();
            edytuj(p.id, p.lat, p.lng);
          });
        }
        const rbtn = container.querySelector(`#routeBtn-${p.id}`);
        if (rbtn) {
          rbtn.addEventListener('click', ev => {
            ev.stopPropagation();
            map.closePopup();
            startRouteDrawing(p);
          });
        }
        const directBtn = container.querySelector(`#routeDirectBtn-${p.id}`);
        if (directBtn) {
          directBtn.addEventListener('click', ev => {
            ev.stopPropagation();
            map.closePopup();
            routeToPin(p, directBtn);
          });
        }
        const planBtn = container.querySelector(`#planBtn-${p.id}`);
        if (planBtn) {
          planBtn.addEventListener('click', ev => {
            ev.stopPropagation();
            map.closePopup();
            startPlanUpload(p);
          });
        }
        updatePopupAddress(container, p.lat, p.lng);
        const range = container.querySelector(`#trudnoscRange-${p.id}`);
        const label = container.querySelector(`#trudnoscLabel-${p.id}`);
        if (range && label) {
          label.textContent = trudnoscText(range.value);
          range.addEventListener('input', () => {
            const val = parseInt(range.value);
            label.textContent = trudnoscText(val);
            const cur = zmianyDoZapisania[p.id] || {};
            cur.trudnosc = val;
            zmianyDoZapisania[p.id] = cur;
            p.trudnosc = val;
            p.unsaved = true;
            updateSaveButton();
          });
        }
      };
      if (marker._editHandler) {
        marker.off('popupopen', marker._editHandler);
      }
      marker._editHandler = handler;
      marker.on('popupopen', handler);
    }

  

    async function setupEmojiInput(input) {
      if (!input) return;
      await emojiListReady;
      const list = document.createElement('div');
      list.className = 'emoji-dropdown';
      const preview = document.createElement('img');
      preview.className = 'emoji-input-preview';
      preview.width = 28;
      preview.height = 28;
      input.parentNode.insertBefore(preview, input.nextSibling);

      function updatePreview() {
        const val = input.value.trim();
        const url = resolveEmoji(val);
        if (url && url.startsWith('http')) {
          preview.src = url;
          preview.style.display = 'inline-block';
        } else {
          preview.style.display = 'none';
        }
      }

      function renderList() {
        list.querySelectorAll('img[data-emoji-item="true"]').forEach(el => el.remove());
        emojiList.forEach(({id, url, info}) => {
          const img = document.createElement('img');
          img.dataset.emojiItem = 'true';
          img.src = url;
          if (info) { img.title = info; img.dataset.info = info; }
          img.width = 24;
          img.height = 24;
          img.style.cursor = 'pointer';
          img.style.margin = '2px';
          img.addEventListener('mousedown', e => {
            e.preventDefault();
            input.value = id;
            updatePreview();
            list.style.display = 'none';
          });
          list.insertBefore(img, addBtn);
        });
      }

      const addBtn = document.createElement('button');
      addBtn.textContent = '+';
      addBtn.className = 'emoji-add-btn';
      addBtn.addEventListener('click', async e => {
        e.preventDefault();
        const url = prompt('URL nowego emoji:');
        if (url) {
          const info = prompt('Nazwa nowego emoji:') || '';
          const id = await addEmojiToList(url, info);
          input.value = id;
          updatePreview();
          list.style.display = 'none';
        }
      });
      list.appendChild(addBtn);
      document.body.appendChild(list);
      renderList();
      subscribeEmojiList(renderList);

      function show() {
        const r = input.getBoundingClientRect();
        list.style.left = r.left + window.scrollX + 'px';
        list.style.top = r.bottom + window.scrollY + 'px';
        list.style.display = 'flex';
      }

      input.addEventListener('focus', show);
      input.addEventListener('click', show);
      input.addEventListener('blur', () => {
        setTimeout(() => { list.style.display = 'none'; }, 100);
      });
      input.addEventListener('input', updatePreview);
      updatePreview();
    }

    async function setupEmojiPicker(container, pin) {
      if (!container || !pin) return;
      await emojiListReady;
      const preview = document.createElement('img');
      preview.className = 'emoji-picker-preview';
      preview.width = 28;
      preview.height = 28;
      function getCurrent() {
        const val = pin.noweEmoji !== undefined ? pin.noweEmoji : pin.emoji;
        if (!val || String(val).trim() === '' || val === 'undefined') {
          return 'https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png';
        }
        return resolveEmoji(val);
      }
      preview.src = getCurrent();
      container.appendChild(preview);

      const grid = document.createElement('div');
      grid.className = 'emoji-picker-grid';
      const addBtn = document.createElement('button');
      addBtn.textContent = '+';
      addBtn.className = 'emoji-add-btn';
      addBtn.addEventListener('click', async e => {
        e.stopPropagation();
        const url = prompt('URL nowego emoji:');
        if (url) {
          const info = prompt('Nazwa nowego emoji:') || '';
          const id = await addEmojiToList(url, info);
          preview.src = url;
          pin.noweEmoji = id;
          grid.style.display = 'none';
        }
      });
      grid.appendChild(addBtn);
      function renderGrid() {
        grid.querySelectorAll('img[data-emoji-item="true"]').forEach(el => el.remove());
        emojiList.forEach(({id, url, info}) => {
          const img = document.createElement('img');
          img.dataset.emojiItem = 'true';
          img.src = url;
          if (info) { img.title = info; img.dataset.info = info; }
          img.addEventListener('click', e => {
            e.stopPropagation();
            preview.src = url;
            pin.noweEmoji = id;
            grid.style.display = 'none';
          });
          grid.insertBefore(img, addBtn);
        });
      }
      renderGrid();
      subscribeEmojiList(renderGrid);
      container.appendChild(grid);

      preview.addEventListener('click', e => {
        e.stopPropagation();
        grid.style.display = grid.style.display === 'grid' ? 'none' : 'grid';
      });
      document.addEventListener('click', function hide(e) {
        if (!container.contains(e.target)) grid.style.display = 'none';
      });
    }

    async function setupEmojiPickerForInput(container, input) {
      if (!container || !input) return;
      await emojiListReady;
      container.innerHTML = '';

      const preview = document.createElement('img');
      preview.className = 'emoji-picker-preview';
      preview.width = 28;
      preview.height = 28;

      const grid = document.createElement('div');
      grid.className = 'emoji-picker-grid';

      function currentUrl() {
        const val = (input.value || '').trim();
        const resolved = resolveEmoji(val);
        return resolved || 'https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png';
      }

      function updatePreview() {
        preview.src = currentUrl();
      }

      const addBtn = document.createElement('button');
      addBtn.textContent = '+';
      addBtn.className = 'emoji-add-btn';
      addBtn.addEventListener('click', async e => {
        e.stopPropagation();
        const url = prompt('URL nowego emoji:');
        if (url) {
          const info = prompt('Nazwa nowego emoji:') || '';
          const id = await addEmojiToList(url, info);
          input.value = id;
          updatePreview();
          grid.style.display = 'none';
        }
      });
      grid.appendChild(addBtn);
      function renderGrid() {
        grid.querySelectorAll('img[data-emoji-item="true"]').forEach(el => el.remove());
        emojiList.forEach(({id, url, info}) => {
          const img = document.createElement('img');
          img.dataset.emojiItem = 'true';
          img.src = url;
          if (info) { img.title = info; img.dataset.info = info; }
          img.addEventListener('click', e => {
            e.stopPropagation();
            input.value = id;
            updatePreview();
            grid.style.display = 'none';
          });
          grid.insertBefore(img, addBtn);
        });
      }
      renderGrid();
      subscribeEmojiList(renderGrid);

      container.appendChild(preview);
      container.appendChild(grid);

      preview.addEventListener('click', e => {
        e.stopPropagation();
        grid.style.display = grid.style.display === 'grid' ? 'none' : 'grid';
      });

      document.addEventListener('click', e => {
        if (!container.contains(e.target)) grid.style.display = 'none';
      });

      input.addEventListener('input', updatePreview);
      updatePreview();
    }

    function setupDropdownInput(input, itemsFn) {
      if (!input) return;
      const wrapper = document.createElement('div');
      wrapper.style.position = 'relative';
      input.parentNode.insertBefore(wrapper, input);
      wrapper.appendChild(input);
      input.style.paddingRight = '20px';
      input.style.boxSizing = 'border-box';
      const arrow = document.createElement('span');
      arrow.textContent = '‚ñº';
      arrow.className = 'dropdown-arrow';
      wrapper.appendChild(arrow);
      const list = document.createElement('div');
      list.className = 'list-dropdown';
      wrapper.appendChild(list);

      function populate() {
        list.innerHTML = '';
        itemsFn().forEach(item => {
          const div = document.createElement('div');
          div.textContent = item;
          div.addEventListener('mousedown', e => {
            e.preventDefault();
            input.value = item;
            hide();
          });
          list.appendChild(div);
        });
      }
      function show() { populate(); list.style.display = 'block'; }
      function hide() { list.style.display = 'none'; }
      arrow.addEventListener('click', e => { e.stopPropagation(); list.style.display === 'block' ? hide() : show(); });
      document.addEventListener('click', e => { if (!wrapper.contains(e.target)) hide(); });
    }

    function setupTrudnoscInput(range, label) {
      if (!range || !label) return;
      function update() {
        label.textContent = trudnoscText(range.value);
        label.style.color = trudnoscColor(range.value);
      }
      update();
      range.addEventListener('input', update);
    }

    function initMap() {
      const OTM_ATTR = '¬© OpenTopoMap (CC BY-SA), ¬© waymarkedtrails.org, ¬© OpenStreetMap (CC BY-SA)';

      const ORTO_ATTR = '¬© GUGiK ‚Äì Orto.';
      const SHADED_RELIEF_ATTR = '¬© GUGiK ‚Äì Cieniowanie';
      // WMTS GetCapabilities: https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMTS/StandardResolution?Service=WMTS&Request=GetCapabilities
      const WMTS_STD_URL = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMTS/StandardResolution';
      const WMTS_HI_URL = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMTS/HighResolution';
      // WMS GetCapabilities: https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMS/StandardResolution?service=WMS&request=GetCapabilities&version=1.3.0
      const WMS_STD_URL = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMS/StandardResolution';
      const WMS_HI_URL = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMS/HighResolution';
      const WMS_TRUE_URL = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMS/TrueOrtho';
      const WMS_ARCH_STD_URL = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMS/StandardResolutionTime';
      const WMS_ARCH_HI_URL = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/WMS/HighResolutionTime';
      const WMS_SHADED_RELIEF_URL = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/NMT/GRID1/WMS/ShadedRelief';
      const WMS_STD_TIME_URL = WMS_ARCH_STD_URL;
      const WMS_HI_TIME_URL = WMS_ARCH_HI_URL;

      function wmtsLayer(url) {
        if (!L.tileLayer.wmts) throw new Error('Brak wtyczki WMTS');
        return L.tileLayer.wmts(url, {
          layer: 'ORTO',
          tilematrixSet: 'EPSG:3857',
          format: 'image/jpeg',
          style: 'default',
          attribution: ORTO_ATTR
        });
      }

      function wmsLayer(url, layerName = 'Raster', options = {}) {
        return L.tileLayer.wms(url, {
          layers: layerName,
          format: 'image/jpeg',
          transparent: false,
          version: '1.3.0',
          uppercase: true,
          crs: L.CRS.EPSG3857,
          attribution: ORTO_ATTR,
          ...options
        });
      }

      function wmsShadedReliefLayer() {
        return wmsLayer(WMS_SHADED_RELIEF_URL, 'Raster', {
          format: 'image/png',
          attribution: SHADED_RELIEF_ATTR
        });
      }

      L.Popup.prototype.options.maxWidth = 800;
      map = L.map('map', { crs: L.CRS.EPSG3857 }).setView([52.1, 20.9], 7);
      map.on('zoomend', () => {
        if (!highlightedMarker || !pinHighlightCircle) return;
        setMarkerHighlight(highlightedMarker);
      });
      const highlightPane = map.createPane('pinHighlightPane');
      const markerPane = map.getPane('markerPane');
      const markerPaneZIndex = markerPane && markerPane.style && markerPane.style.zIndex
        ? parseInt(markerPane.style.zIndex, 10)
        : 600;
      highlightPane.style.zIndex = String(markerPaneZIndex - 1);
      highlightPane.style.pointerEvents = 'none';
      rysowaneTrasy.addTo(map);
      routingLayer = L.layerGroup().addTo(map);

      // Undo/redo should ignore map view changes, so no actions are
      // recorded for map movements.

      // Leaflet handles popup autopan; avoid manual centering to prevent double-pan lag.

      const sat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Esri'
      });
      const hill = wmsShadedReliefLayer();
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      });
      const labels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}');
      const roadsFull = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}');
      const roadsSimple = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}', { maxNativeZoom: 12, maxZoom: 18 });

      const baseOpenTopoPlusTrails = {
        base: L.tileLayer('https://tile.opentopomap.org/{z}/{x}/{y}.png', {
          maxZoom: 17,
          attribution: '¬© OpenTopoMap (CC BY-SA), ¬© OpenStreetMap'
        }),
        overlay: L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', {
          opacity: 0.6,
          attribution: '¬© waymarkedtrails.org, ¬© OpenStreetMap (CC BY-SA)'
        })
      };

      const baseLayerDefs = {
        sat: { create: () => sat },
        hill: { create: () => hill },
        'otm-trails': { create: () => baseOpenTopoPlusTrails.base },
        osm: { create: () => osm },
        'orto-wmts-std': { create: () => wmtsLayer(WMTS_STD_URL), fallback: 'orto-wms-std' },
        'orto-wmts-hi': { create: () => wmtsLayer(WMTS_HI_URL), fallback: 'orto-wms-hi' },
        'orto-wms-std': { create: () => wmsLayer(WMS_STD_URL), fallback: 'orto-wmts-std' },
        'orto-wms-hi': { create: () => wmsLayer(WMS_HI_URL), fallback: 'orto-wmts-hi' },
        'orto-wms-std-time': { create: () => wmsLayer(WMS_STD_TIME_URL) },
        'orto-wms-hi-time': { create: () => wmsLayer(WMS_HI_TIME_URL) },
        // TrueOrtho WMS layer uses the default 'Raster' layer name
        // Removing the explicit layer parameter fixes loading issues
        'true-orto': { create: () => wmsLayer(WMS_TRUE_URL) }
      };

      const overlays = {
        archStd: wmsLayer(WMS_ARCH_STD_URL),
        archHi: wmsLayer(WMS_ARCH_HI_URL),
        shade: wmsShadedReliefLayer()
      };
      overlays.archStd.on('tileerror', () => showToast('Sprawd≈∫ parametry warstwy (layers/CRS/format).'));
      overlays.archHi.on('tileerror', () => showToast('Sprawd≈∫ parametry warstwy (layers/CRS/format).'));
      overlays.shade.on('tileerror', () => showToast('Nie uda≈Ço siƒô za≈Çadowaƒá cieniowania (Geoportal WMS).'));

      const mapDateBadgeEl = document.getElementById('map-date-badge');
      const mapYearSelect = document.getElementById('map-year-select');
      const timeLayerYears = {};

      function to3857(latlng) {
        return L.CRS.EPSG3857.project(latlng);
      }
      function to4326(point) {
        return L.CRS.EPSG3857.unproject(point);
      }
      function boundsToExtent4326(bounds) {
        const sw = to4326(to3857(bounds.getSouthWest()));
        const ne = to4326(to3857(bounds.getNorthEast()));
        return [sw.lng, sw.lat, ne.lng, ne.lat].join(',');
      }

      function resetMapDateControls() {
        if (mapYearSelect) {
          mapYearSelect.style.display = 'none';
          mapYearSelect.innerHTML = '';
          mapYearSelect.onchange = null;
        }
        if (mapDateBadgeEl) mapDateBadgeEl.textContent = '';
        if (map) map.off('contextmenu', handleEsriIdentify);
      }

      function setBadge(text) {
        if (mapDateBadgeEl) mapDateBadgeEl.textContent = text;
      }

      async function initGeoportalTime(layerKey, url) {
        try {
          let years = timeLayerYears[url];
          if (!years) {
            const res = await fetch(`${url}?service=WMS&request=GetCapabilities&version=1.3.0`);
            if (!res.ok) throw new Error('cap');
            const text = await res.text();
            const xml = new DOMParser().parseFromString(text, 'text/xml');
            if (xml.querySelector('ServiceException')) throw new Error('service');
            const dim = xml.querySelector('Dimension[name="time"], Extent[name="time"]');
            if (!dim) throw new Error('cap');
            years = dim.textContent.split(',').map(s => s.trim()).filter(Boolean).sort((a, b) => b.localeCompare(a));
            timeLayerYears[url] = years;
          }
          const saved = localStorage.getItem(`ortoTimeYear:${layerKey}`);
          const year = (saved && years.includes(saved)) ? saved : years[0];
          years.forEach(y => {
            const opt = document.createElement('option');
            opt.value = y;
            opt.textContent = y;
            mapYearSelect.appendChild(opt);
          });
          mapYearSelect.value = year;
          mapYearSelect.style.display = 'inline-block';
          setBadge(`Orto: ${year}`);
          baseLayer.setParams({ time: year });
          mapYearSelect.onchange = () => {
            const newYear = mapYearSelect.value;
            const prevYear = baseLayer.options.time;
            setBadge(`Orto: ${newYear}`);
            const onError = () => {
              showToast('B≈ÇƒÖd WMS (Time). Sprawd≈∫ parametry warstwy.');
              baseLayer.setParams({ time: prevYear });
              mapYearSelect.value = prevYear;
              setBadge(`Orto: ${prevYear}`);
              baseLayer.off('tileerror', onError);
              baseLayer.off('load', onLoad);
            };
            const onLoad = () => {
              baseLayer.off('tileerror', onError);
              baseLayer.off('load', onLoad);
              localStorage.setItem(`ortoTimeYear:${layerKey}`, newYear);
            };
            baseLayer.on('tileerror', onError);
            baseLayer.on('load', onLoad);
            baseLayer.setParams({ time: newYear });
          };
        } catch (e) {
          if (e.message === 'service') {
            showToast('B≈ÇƒÖd WMS (Time). Sprawd≈∫ parametry warstwy.');
          } else {
            showToast('Nie uda≈Ço siƒô pobraƒá listy lat. Spr√≥buj ponownie.');
          }
          setBadge('Orto: mozaika (brak jednego roku)');
          if (mapYearSelect) mapYearSelect.style.display = 'none';
        }
      }

      async function handleEsriIdentify(e) {
        if (e.originalEvent && typeof e.originalEvent.preventDefault === 'function') {
          e.originalEvent.preventDefault();
        }
        const { lat, lng } = e.latlng;
        const size = map.getSize();
        const bounds = map.getBounds();
        const params = new URLSearchParams({
          f: 'json',
          geometry: `${lng},${lat}`,
          geometryType: 'esriGeometryPoint',
          sr: 4326,
          tolerance: 1,
          mapExtent: boundsToExtent4326(bounds),
          imageDisplay: `${size.x},${size.y},96`,
          returnGeometry: false
        });
        try {
          const res = await fetch(`https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/identify?${params.toString()}`);
          if (!res.ok) throw new Error('id');
          const data = await res.json();
          let dateStr = null;
          if (data.results && data.results.length && data.results[0].attributes) {
            const attrs = data.results[0].attributes;
            const field = ['AcquisitionDate','SRCDATE','SRC_DATE','Best','Captured','Date'].find(k => attrs[k]);
            if (field) {
              dateStr = attrs[field];
              const d = new Date(dateStr);
              if (!isNaN(d)) dateStr = d.toISOString().split('T')[0];
            }
          }
          const content = dateStr ? `Esri ‚Äì data pozyskania: ${dateStr}` : 'Esri ‚Äì data pozyskania: brak metadanych';
          L.popup().setLatLng(e.latlng).setContent(content).openOn(map);
          setBadge(dateStr ? `Esri: ${dateStr}` : 'Esri: brak metadanych');
        } catch (err) {
          showToast('Nie uda≈Ço siƒô pobraƒá metadanych Esri dla tego punktu.');
        }
      }

      const isTouchDevice = 'ontouchstart' in window || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);

      function updateMapDateUI(key) {
        resetMapDateControls();
        if (key === 'orto-wms-std-time') {
          initGeoportalTime(key, WMS_STD_TIME_URL);
        } else if (key === 'orto-wms-hi-time') {
          initGeoportalTime(key, WMS_HI_TIME_URL);
        } else if (['orto-wmts-std','orto-wmts-hi','orto-wms-std','orto-wms-hi','true-orto'].includes(key)) {
          setBadge('Orto: mozaika (brak jednego roku)');
        } else if (key === 'sat') {
          if (isTouchDevice) {
            setBadge('Esri: przytrzymaj, aby dodaƒá pinezkƒô');
          } else {
            setBadge('Esri: kliknij prawym przyciskiem, aby sprawdziƒá datƒô');
            map.on('contextmenu', handleEsriIdentify);
          }
        } else if (key === 'otm-trails') {
          setBadge('Topo (OSM): brak daty');
        }
      }

      function switchBaseLayer(key, isFallback = false) {
        baseLayerLoadToken++;
        const loadToken = baseLayerLoadToken;
        resetBaseLayerLoading();
        const def = baseLayerDefs[key] || baseLayerDefs['osm'];
        if (currentBase === 'otm-trails') {
          if (waymarkedErrorHandler) {
            baseOpenTopoPlusTrails.overlay.off('tileerror', waymarkedErrorHandler);
            waymarkedErrorHandler = null;
          }
          if (map.hasLayer(baseOpenTopoPlusTrails.overlay)) {
            map.removeLayer(baseOpenTopoPlusTrails.overlay);
          }
          map.attributionControl.removeAttribution(OTM_ATTR);
        }
        if (baseLayer) {
          if (baseLayerLoadingHandler) baseLayer.off('loading', baseLayerLoadingHandler);
          if (baseLayerLoadedHandler) baseLayer.off('load', baseLayerLoadedHandler);
          if (baseTileErrorHandler) baseLayer.off('tileerror', baseTileErrorHandler);
          if (baseLayer._abortLoading) baseLayer._abortLoading();
          map.removeLayer(baseLayer);
        }
        try {
          baseLayer = def.create();
        } catch (e) {
          if (def.fallback && !isFallback) {
            showToast('WMTS niedostƒôpny, prze≈ÇƒÖczam na WMS.');
            switchBaseLayer(def.fallback, true);
            return;
          } else {
            showToast('Nie mo≈ºna wczytaƒá warstwy.');
            baseLayer = baseLayerDefs['osm'].create();
            key = 'osm';
          }
        }
        if (key === 'orto-wms-std-time' || key === 'orto-wms-hi-time') {
          baseTileErrorHandler = () => {
            showToast('B≈ÇƒÖd WMS (Time). Sprawd≈∫ parametry warstwy.');
          };
        } else {
          baseTileErrorHandler = () => {
            if (def.fallback && !isFallback) {
              showToast('Sprawd≈∫ parametry warstwy (layers/CRS/format). Prze≈ÇƒÖczam na WMS/WMTS.');
              switchBaseLayer(def.fallback, true);
            } else {
              showToast('B≈ÇƒÖd ≈Çadowania warstwy.');
            }
          };
        }
        baseLayerLoadingHandler = () => {
          if (loadToken !== baseLayerLoadToken) return;
          baseLayerLoadingCount++;
          showLoading();
        };
        baseLayerLoadedHandler = () => {
          if (loadToken !== baseLayerLoadToken) return;
          if (baseLayerLoadingCount > 0) {
            baseLayerLoadingCount--;
            hideLoading();
          }
        };
        baseLayer.on('tileerror', baseTileErrorHandler);
        baseLayer.on('loading', baseLayerLoadingHandler);
        baseLayer.on('load', baseLayerLoadedHandler);
        baseLayer.addTo(map);
        if (key === 'otm-trails') {
          baseOpenTopoPlusTrails.overlay.addTo(map);
          waymarkedErrorHandler = () => {
            showToast('Nie uda≈Ço siƒô za≈Çadowaƒá nak≈Çadki szlak√≥w (Waymarked). Mapa OpenTopo pozostaje w≈ÇƒÖczona.');
            baseOpenTopoPlusTrails.overlay.off('tileerror', waymarkedErrorHandler);
            waymarkedErrorHandler = null;
          };
          baseOpenTopoPlusTrails.overlay.on('tileerror', waymarkedErrorHandler);
          map.attributionControl.removeAttribution('¬© OpenTopoMap (CC BY-SA), ¬© OpenStreetMap');
          map.attributionControl.removeAttribution('¬© waymarkedtrails.org, ¬© OpenStreetMap (CC BY-SA)');
          map.attributionControl.addAttribution(OTM_ATTR);
        }
        map.removeLayer(labels);
        if (roadsLayer) map.removeLayer(roadsLayer);
        if (key !== 'osm') {
          labels.addTo(map);
          if (roadsLayer) roadsLayer.addTo(map);
        }
        currentBase = key;
        updateMapDateUI(key);
      }

      roadsLayer = roadsFull;
      switchBaseLayer('sat');

      document.querySelectorAll('input[name="basemap"]').forEach(radio => {
        radio.addEventListener('change', () => switchBaseLayer(radio.value));
      });

      const overlayCheckboxIds = { archStd: 'overlay-arch-std', archHi: 'overlay-arch-hi', shade: 'overlay-shade' };
      ['archStd','archHi','shade'].forEach(key => {
        const checkbox = document.getElementById(overlayCheckboxIds[key]);
        if (checkbox) {
          checkbox.addEventListener('change', e => {
            if (e.target.checked) overlays[key].addTo(map);
            else map.removeLayer(overlays[key]);
          });
        }

        const btn = document.querySelector(`.opacity-btn[data-target="${key}"]`);
        const slider = document.getElementById(`opacity-${key}`);
        if (btn && slider) {
          btn.addEventListener('click', () => {
            slider.classList.toggle('ukryta');
          });
          slider.addEventListener('input', ev => {
            overlays[key].setOpacity(ev.target.value / 100);
          });
        }
      });

      document.querySelectorAll('.info-btn').forEach(btn => {
        btn.addEventListener('click', ev => {
          ev.preventDefault();
          ev.stopPropagation();
          showToast(btn.dataset.info);
        });
      });

      document.querySelectorAll('input[name="streets"]').forEach(radio => {
        radio.addEventListener('change', () => {
          if (roadsLayer) map.removeLayer(roadsLayer);
          roadsLayer = (radio.value === 'main') ? roadsSimple :
                       (radio.value === 'full') ? roadsFull : null;
          if (currentBase !== 'osm' && roadsLayer) roadsLayer.addTo(map);
        });
      });
    map.on("click", e => { if (currentTool === "pin" && !drawingRoute && window.innerWidth > 800) onMapClick(e); });
    map.on(L.Draw.Event.CREATED, onRouteCreated);
    map.on('draw:drawstop', () => { drawingRoute = false; activeRoutePin = null; });

    if (window.innerWidth <= 700) {
      let startLatLng = null;
      let startPoint = null;
      let startTime = 0;
      let moved = false;
      map.on('touchstart', e => {
        startLatLng = e.latlng;
        startPoint = e.containerPoint;
        startTime = Date.now();
        moved = false;
      });
      map.on('touchmove', e => {
        if (!startPoint) return;
        if (e.containerPoint.distanceTo(startPoint) > 5) {
          moved = true;
        }
      });
      map.on('touchend', () => {
        if (!moved && startLatLng && Date.now() - startTime >= 2000) {
          openNewPinPopup(startLatLng);
        }
        startLatLng = null;
        startPoint = null;
      });
      map.on('dragstart', () => {
        if (followGps) {
          followGps = false;
          const btn = document.getElementById('gpsFollowBtn');
          if (btn) btn.style.display = 'block';
        }
      });
    }

    }

    async function ensureLayerEntry(layerName, orderList = []) {
      if (!layerName) return;
      if (layerDocs[layerName]) {
        if (Array.isArray(orderList) && !orderList.includes(layerName)) {
          orderList.push(layerName);
        }
        if (!warstwy[layerName]) {
          warstwy[layerName] = { lista: [], layer: L.layerGroup(), collapsed: true, emoji: '', loaded: false, loading: false, defaultVisible: true };
        }
        return;
      }
      try {
        const payload = { name: layerName, order: Array.isArray(orderList) ? orderList.length : Object.keys(layerDocs).length };
        const docRef = await db.collection('layers').add(payload);
        layerDocs[layerName] = docRef.id;
        layerNamesById[docRef.id] = layerName;
        if (Array.isArray(orderList) && !orderList.includes(layerName)) {
          orderList.push(layerName);
        }
        if (!warstwy[layerName]) {
          warstwy[layerName] = { lista: [], layer: L.layerGroup(), collapsed: true, emoji: '', loaded: false, loading: false, defaultVisible: true };
        }
      } catch (e) {
        console.error('B≈ÇƒÖd dodawania warstwy do Firestore', e);
        if (!warstwy[layerName]) {
          warstwy[layerName] = { lista: [], layer: L.layerGroup(), collapsed: true, emoji: '', loaded: false, loading: false, defaultVisible: true };
        }
      }
    }

    async function loadLayersFromFirestore() {
      try {
        const snap = await db.collection('layers').orderBy('order').get();
        const order = [];
        snap.forEach(doc => {
          const data = doc.data();
          layerDocs[data.name] = doc.id;
          layerNamesById[doc.id] = data.name;
          if (data.name === 'Sztosy') sztosyId = doc.id;
          if (data.name && data.name.toLowerCase() === 'zwiedzone i niedostƒôpne') visitedId = doc.id;
          if (data.name === 'Tryb w ruchu') movingLayerId = doc.id;
          order.push(data.name);
          if (!warstwy[data.name]) {
            warstwy[data.name] = { lista: [], layer: L.layerGroup(), collapsed: true, emoji: data.emoji || '', loaded: false, loading: false, defaultVisible: data.defaultVisible !== undefined ? !!data.defaultVisible : true };
          } else {
            if (data.emoji) {
              warstwy[data.name].emoji = data.emoji;
            }
            if (data.defaultVisible !== undefined) {
              warstwy[data.name].defaultVisible = !!data.defaultVisible;
            } else if (warstwy[data.name].defaultVisible === undefined) {
              warstwy[data.name].defaultVisible = true;
            }
          }
        });
        if (order.length > 0) {
          localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(order));
          initialLayerOrder = [...order];
          layerOrderChanged = false;
        }
      } catch (e) {
        console.error('B≈ÇƒÖd wczytywania warstw', e);
      }
    }

    
function zaladujPinezkiZFirestore() {
  showLoading();
  const pinSources = [{ collection: "pinezki2", layerOverride: null }];
  if (warstwy[PINTEREST_LAYER_NAME] || layerDocs[PINTEREST_LAYER_NAME]) {
    pinSources.push({ collection: PINTEREST_PINS_COLLECTION, layerOverride: PINTEREST_LAYER_NAME });
  }
  Promise.all(pinSources.map(source => db.collection(source.collection).get()))
  .then(snaps => {
    snaps.forEach((snapshot, idx) => {
      const source = pinSources[idx];
      snapshot.forEach(doc => {
      const p = doc.data();
      if (source.layerOverride) {
        p.warstwa = source.layerOverride;
      }
      if (p.dataDodania && p.dataDodania.seconds !== undefined) {
        p.dataDodania = p.dataDodania.seconds * 1000;
      } else if (typeof p.dataDodania === 'string' || p.dataDodania instanceof Date) {
        p.dataDodania = new Date(p.dataDodania).getTime();
      }
      const firebaseId = doc.id;
      const id = p.IDpinezki;
      p.firebaseId = firebaseId;
      p.id = id;
      if (p.trudnosc !== undefined) {
        p.trudnosc = parseInt(p.trudnosc, 10);
      }
      p.nieaktywne = p.nieaktywne === true;
      p.zamkniete = p.zamkniete === true;
      p.doSprawdzenia = p.doSprawdzenia === true;
      p.zdewastowane = p.zdewastowane === true;
      p.zwiedzone = p.zwiedzone === true;
      p.wyroznione = p.wyroznione === true;
      p.slug = slugify(p.nazwa);
      if (!photosMap[p.slug]) {
        // 1) Start od legacy 'photo' (je≈õli istnieje) ‚Äì jako PIERWSZE
        const merged = [];
        if (p.photo && typeof p.photo === 'string' && p.photo.trim()) {
          merged.push({ url: normalizePhotoUrl(p.photo), legacy: true });
        }

        // 2) Dorzuƒá 'photos' (je≈õli sƒÖ)
        if (Array.isArray(p.photos)) {
          for (const x of p.photos) {
            if (x && x.url) merged.push({ ...x, url: normalizePhotoUrl(x.url) });
          }
        }

        // 3) Deduplikacja po URL
        const seen = new Set();
        const dedup = [];
        for (const ph of merged) {
          if (!ph || !ph.url) continue;
          if (seen.has(ph.url)) continue;
          seen.add(ph.url);
          dedup.push(ph);
        }

        storePhotos(p.slug, dedup);
      }
      categories.add(p.kategoria || '');
      const layerInfo = resolveLayerInfo(p.warstwa, p.warstwaId);
      p.warstwaId = layerInfo.warstwaId || null;
      p.warstwa = layerInfo.warstwaName;
      const warstwaNazwa = p.warstwa || "Inne";
      if (warstwaNazwa === PINTEREST_LAYER_NAME && !warstwy[warstwaNazwa]) {
        return;
      }
      if (!warstwy[warstwaNazwa]) {
        warstwy[warstwaNazwa] = {
          lista: [],
          layer: L.layerGroup(),
          collapsed: true,
          emoji: '',
          defaultVisible: true
        };
      }

      const iconEmoji = warstwy[warstwaNazwa].emoji || p.emoji;
      const marker = L.marker([p.lat, p.lng], { icon: createEmojiIcon(iconEmoji, p.warstwaId, 32, p) }).addTo(warstwy[warstwaNazwa].layer);
      if (p.trasy) {
        p.trasy.forEach(tr => {
          const color = tr.kolor || DEFAULT_ROUTE_COLOR;
          const opacity = getRouteOpacity(tr);
          tr.przezroczystosc = opacity;
          const layer = L.polyline(tr.punkty.map(pt => [pt.lat, pt.lng]), {color, weight:4, className:'route-line', opacity}).addTo(rysowaneTrasy);
          tr.layer = layer;
          layer.on('click', e => showRoutePopup(p.id, tr, e.latlng));
        });
      } else {
        p.trasy = [];
      }
      if (Array.isArray(p.plany)) {
        p.plany.forEach(pl => {
          ensurePlanDefaults(pl, p);
          ensurePlanOverlay(p, pl);
        });
      } else {
        p.plany = [];
      }
      p.savedPlans = serializePlans(p);
      const popupDiv = document.createElement("div");
      popupDiv.className = "popup-container";
      popupDiv.innerHTML = createPopupHtml(p);
      marker.bindPopup(popupDiv);
      attachPopupHandlers(marker, p);
      attachMarkerLongPress(marker, p);
      attachHighlight(marker, null);

      p.marker = marker;
      applyInactiveStyle(p);
      warstwy[warstwaNazwa].lista.push(p);
      warstwy[warstwaNazwa].loaded = true;
      wszystkiePinezki.push(p);
    });
    });
    if (!localPinsLoaded) loadNewPinsFromLocal();
    updateCategoryFilter();
    updateStatusFilter();
    generujListeWarstw();
  })
  .catch(err => {
    console.error("B≈ÇƒÖd pobierania pinezek:", err);
    if (!localPinsLoaded) loadNewPinsFromLocal();
    updateCategoryFilter();
    updateStatusFilter();
    generujListeWarstw();
  }).finally(() => {
    hideLoading();
  });
}

    function buildStatusGrid(prefix = '', suffix = '', status = {}) {
      return `
        <div class="status-grid">
          <label><input type="checkbox" id="${prefix}nieaktywne${suffix}" ${status.nieaktywne ? 'checked' : ''}> Niedostƒôpne <span class="status-emoji">‚õî</span></label>
          <label><input type="checkbox" id="${prefix}zamkniete${suffix}" ${status.zamkniete ? 'checked' : ''}> Zamkniƒôte <span class="status-emoji">üîê</span></label>
          <label><input type="checkbox" id="${prefix}tajne${suffix}" ${status.tajne ? 'checked' : ''}> Tajne <span class="status-emoji">ü§´</span></label>
          <label><input type="checkbox" id="${prefix}doSprawdzenia${suffix}" ${status.doSprawdzenia ? 'checked' : ''}> Do sprawdzenia <span class="status-emoji">‚ùî</span></label>
          <label><input type="checkbox" id="${prefix}zdewastowane${suffix}" ${status.zdewastowane ? 'checked' : ''}> Zdewastowane <span class="status-emoji">üí•</span></label>
          <label><input type="checkbox" id="${prefix}zwiedzone${suffix}" ${status.zwiedzone ? 'checked' : ''}> Zwiedzone <img src="https://upload.wikimedia.org/wikipedia/commons/0/03/Green_check.svg" class="status-emoji checkmark-obrys"></label>
          <label><input type="checkbox" id="${prefix}wyroznione${suffix}" ${status.wyroznione ? 'checked' : ''}> Wyr√≥≈ºnione <span class="status-emoji">‚≠ê</span></label>
        </div>
      `;
    }

    function captureEditDraft(pin, container) {
      if (!pin || !container) return;
      const draft = {};
      const nameInput = container.querySelector('#enazwa');
      if (nameInput) draft.nazwa = nameInput.value;
      const opisInput = container.querySelector('#eopis');
      if (opisInput) draft.opis = opisInput.value;
      const odKogoInput = container.querySelector('#eodKogo');
      if (odKogoInput) draft.odKogo = odKogoInput.value;
      const warstwaInput = container.querySelector('#ewarstwa');
      if (warstwaInput) draft.warstwa = warstwaInput.value;
      const kategoriaInput = container.querySelector('#ekategoria');
      if (kategoriaInput) draft.kategoria = kategoriaInput.value;
      const trudInput = container.querySelector('#etrudnosc');
      if (trudInput) draft.trudnosc = trudInput.value;
      const status = {};
      const setStatus = (key, selector) => {
        const el = container.querySelector(selector);
        if (el) status[key] = el.checked;
      };
      setStatus('nieaktywne', '#enieaktywne');
      setStatus('zamkniete', '#ezamkniete');
      setStatus('tajne', '#etajne');
      setStatus('doSprawdzenia', '#edoSprawdzenia');
      setStatus('zdewastowane', '#ezdewastowane');
      setStatus('zwiedzone', '#ezwiedzone');
      setStatus('wyroznione', '#ewyroznione');
      draft.status = status;
      pin._editDraft = draft;
    }

    function applyEditDraft(pin, container) {
      if (!pin || !container || !pin._editDraft) return;
      const draft = pin._editDraft;
      const setValue = (selector, value) => {
        if (value === undefined) return;
        const el = container.querySelector(selector);
        if (el) el.value = value;
      };
      setValue('#enazwa', draft.nazwa);
      setValue('#eopis', draft.opis);
      setValue('#eodKogo', draft.odKogo);
      setValue('#ewarstwa', draft.warstwa);
      setValue('#ekategoria', draft.kategoria);
      setValue('#etrudnosc', draft.trudnosc);
      const trudInput = container.querySelector('#etrudnosc');
      if (trudInput && draft.trudnosc !== undefined) {
        trudInput.value = draft.trudnosc;
        const label = container.querySelector('#etrudnoscLabel');
        if (label) {
          label.textContent = trudnoscText(trudInput.value);
          label.style.color = trudnoscColor(trudInput.value);
        }
      }
      const status = draft.status || {};
      const setChecked = (selector, value) => {
        if (value === undefined) return;
        const el = container.querySelector(selector);
        if (el) el.checked = value;
      };
      setChecked('#enieaktywne', status.nieaktywne);
      setChecked('#ezamkniete', status.zamkniete);
      setChecked('#etajne', status.tajne);
      setChecked('#edoSprawdzenia', status.doSprawdzenia);
      setChecked('#ezdewastowane', status.zdewastowane);
      setChecked('#ezwiedzone', status.zwiedzone);
      setChecked('#ewyroznione', status.wyroznione);
      delete pin._editDraft;
    }

    function startPinReposition(pin, container) {
      if (!map || !pin || !pin.marker) return;
      if (pinRepositionState) {
        finishPinReposition(false);
      }
      captureEditDraft(pin, container);
      const marker = pin.marker;
      if (marker._editCloseHandler) {
        marker.off('popupclose', marker._editCloseHandler);
      }
      marker.closePopup();
      const originalLatLng = marker.getLatLng();
      const existing = zmianyDoZapisania[pin.id];
      const previousPending = existing ? { lat: existing.lat, lng: existing.lng } : null;
      const moveHandler = e => {
        marker.setLatLng(e.latlng);
      };
      const confirmHandler = e => {
        if (e.originalEvent) {
          L.DomEvent.stop(e.originalEvent);
        }
        finishPinReposition(true, e.latlng);
      };
      const keyHandler = e => {
        if (e.key === 'Escape') {
          finishPinReposition(false);
        }
      };
      pinRepositionState = {
        pin,
        marker,
        originalLatLng,
        moveHandler,
        confirmHandler,
        keyHandler,
        previousPending
      };
      map.on('mousemove', moveHandler);
      map.on('click', confirmHandler);
      document.addEventListener('keydown', keyHandler);
      const mapContainer = map.getContainer();
      if (mapContainer) mapContainer.classList.add('pin-reposition');
      showToast('Wska≈º nowe miejsce pinezki i kliknij, aby zatwierdziƒá. Naci≈õnij Esc, aby anulowaƒá.');
    }

    function finishPinReposition(confirmed, latlng) {
      if (!pinRepositionState) return;
      const { pin, marker, originalLatLng, moveHandler, confirmHandler, keyHandler, previousPending } = pinRepositionState;
      pinRepositionState = null;
      map.off('mousemove', moveHandler);
      map.off('click', confirmHandler);
      document.removeEventListener('keydown', keyHandler);
      const mapContainer = map.getContainer();
      if (mapContainer) mapContainer.classList.remove('pin-reposition');
      if (confirmed && latlng) {
        const newLatLng = L.latLng(latlng.lat, latlng.lng);
        marker.setLatLng(newLatLng);
        pin.lat = newLatLng.lat;
        pin.lng = newLatLng.lng;
        markPinUnsaved(pin.slug);
        pin.unsaved = true;
        const pending = zmianyDoZapisania[pin.id] || {};
        pending.lat = pin.lat;
        pending.lng = pin.lng;
        zmianyDoZapisania[pin.id] = pending;
        const prevLatLng = L.latLng(originalLatLng.lat, originalLatLng.lng);
        pushAction({
          undo: () => {
            marker.setLatLng(prevLatLng);
            pin.lat = prevLatLng.lat;
            pin.lng = prevLatLng.lng;
            const data = zmianyDoZapisania[pin.id] || {};
            if (previousPending && previousPending.lat !== undefined && previousPending.lng !== undefined) {
              data.lat = previousPending.lat;
              data.lng = previousPending.lng;
              zmianyDoZapisania[pin.id] = data;
            } else {
              delete data.lat;
              delete data.lng;
              if (Object.keys(data).length === 0) {
                delete zmianyDoZapisania[pin.id];
              } else {
                zmianyDoZapisania[pin.id] = data;
              }
            }
            generujListeWarstw();
            updateSaveButton();
          },
          redo: () => {
            marker.setLatLng(newLatLng);
            pin.lat = newLatLng.lat;
            pin.lng = newLatLng.lng;
            const data = zmianyDoZapisania[pin.id] || {};
            data.lat = newLatLng.lat;
            data.lng = newLatLng.lng;
            zmianyDoZapisania[pin.id] = data;
            generujListeWarstw();
            updateSaveButton();
          }
        }, 'Przeniesiono pinezkƒô');
        generujListeWarstw();
        updateSaveButton();
        setTimeout(() => edytuj(pin.id, pin.lat, pin.lng), 0);
        showToast('Nowe po≈Ço≈ºenie pinezki ustawione. Pamiƒôtaj o zapisaniu zmian.');
      } else {
        marker.setLatLng(originalLatLng);
        pin.lat = originalLatLng.lat;
        pin.lng = originalLatLng.lng;
        setTimeout(() => edytuj(pin.id, pin.lat, pin.lng), 0);
        showToast('Przenoszenie pinezki anulowane.');
      }
    }

    function edytuj(id, lat, lng) {
     /* console.log('Wywo≈Çano edytuj dla id:', id, 'lat:', lat, 'lng:', lng); // <-- dodane */
      const p = wszystkiePinezki.find(pp => pp.id === id);
      if (!p) return;
      const layerLabel = resolveLayerInfo(p.warstwa, p.warstwaId).warstwaName || '';
      delete p.noweEmoji;
      const container = document.createElement("div");
      container.className = "popup-container edit-popup";
      container.innerHTML = `
        <div class="photo-gallery" data-slug="${p.slug}"></div>
        <button class="popup-add-photo" data-slug="${p.slug}">üì∑</button>
        <input id="enazwa" value="${p.nazwa}" style="width: 100%"><br>
        <textarea id="eopis" style="width: 100%; height: 50px"></textarea><br>
        <input id="eodKogo" value="${p.odKogo || ''}" placeholder="Od kogo" style="width: 100%"><br>
        <input id="ewarstwa" value="${layerLabel}" placeholder="Warstwa" style="width: 100%"><br>
        <input id="ekategoria" value="${p.kategoria || ''}" placeholder="Kategoria" style="width: 100%"><br>
        <div class="trudnosc-wrapper">
          <div class="trudnosc-title">Poziom trudno≈õci</div>
          <input type="range" id="etrudnosc" class="trudnosc-range" min="0" max="5" step="1" value="${p.trudnosc ?? 0}">
          <div class="trudnosc-labels">
            <span>Nieznany</span><span>B.≈Çatwy</span><span>≈Åatwy</span><span>≈öredni</span><span>Trudny</span><span>B.trudny</span>
          </div>
          <div class="trudnosc-value" id="etrudnoscLabel" style="color:${trudnoscColor(p.trudnosc ?? 0)}">${trudnoscText(p.trudnosc ?? 0)}</div>
        </div>
        ${buildStatusGrid('e', '', p)}
        <button id="movePinBtn-${id}">üìç Zmie≈Ñ po≈Ço≈ºenie</button>
        <button onclick="zapiszLokalnie('${id}')">üíæ Zapisz</button>
        <button id="deleteBtn-${id}">üóëÔ∏è</button>
        <div id="emojiPicker-${id}" class="emoji-picker"></div>
      `;
      L.DomEvent.disableClickPropagation(container);
      const eOpisInput = container.querySelector('#eopis');
      if (eOpisInput) {
        eOpisInput.value = (p.opis || '').replace(/<br\s*\/?>/gi, '\n');
      }
      applyEditDraft(p, container);
      setupEmojiPicker(container.querySelector(`#emojiPicker-${id}`), p);
      setupGallery(container.querySelector('.photo-gallery'));
      setupDropdownInput(container.querySelector('#ewarstwa'), () => Object.keys(warstwy));
      setupDropdownInput(container.querySelector('#ekategoria'), () => Array.from(categories).filter(c => c));
      setupAddPhotoButton(container.querySelector('.popup-add-photo'), p.slug, container.querySelector('.photo-gallery'));
      setupTrudnoscInput(container.querySelector('#etrudnosc'), container.querySelector('#etrudnoscLabel'));
      const chkInactive = container.querySelector('#enieaktywne');
      if (chkInactive) {
        chkInactive.addEventListener('change', () => {
          p.nieaktywne = chkInactive.checked;
          markPinUnsaved(p.slug);
          applyInactiveStyle(p);
          if (p.marker) p.marker.setIcon(createEmojiIcon(p.emoji, p.warstwaId, 32, p));
        });
      }
      const chkClosed = container.querySelector('#ezamkniete');
      if (chkClosed) {
        chkClosed.addEventListener('change', () => {
          p.zamkniete = chkClosed.checked;
          markPinUnsaved(p.slug);
          if (p.marker) p.marker.setIcon(createEmojiIcon(p.emoji, p.warstwaId, 32, p));
        });
      }
      const chkSecret = container.querySelector('#etajne');
      if (chkSecret) {
        chkSecret.addEventListener('change', () => {
          p.tajne = chkSecret.checked;
          markPinUnsaved(p.slug);
          if (p.marker) p.marker.setIcon(createEmojiIcon(p.emoji, p.warstwaId, 32, p));
        });
      }
      const chkTodo = container.querySelector('#edoSprawdzenia');
      if (chkTodo) {
        chkTodo.addEventListener('change', () => {
          p.doSprawdzenia = chkTodo.checked;
          markPinUnsaved(p.slug);
          if (p.marker) p.marker.setIcon(createEmojiIcon(p.emoji, p.warstwaId, 32, p));
        });
      }
      const chkDestroyed = container.querySelector('#ezdewastowane');
      if (chkDestroyed) {
        chkDestroyed.addEventListener('change', () => {
          p.zdewastowane = chkDestroyed.checked;
          markPinUnsaved(p.slug);
          if (p.marker) p.marker.setIcon(createEmojiIcon(p.emoji, p.warstwaId, 32, p));
        });
      }
      const chkVisited = container.querySelector('#ezwiedzone');
      if (chkVisited) {
        chkVisited.addEventListener('change', () => {
          p.zwiedzone = chkVisited.checked;
          markPinUnsaved(p.slug);
          if (p.marker) p.marker.setIcon(createEmojiIcon(p.emoji, p.warstwaId, 32, p));
        });
      }
      const chkHighlighted = container.querySelector('#ewyroznione');
      if (chkHighlighted) {
        chkHighlighted.addEventListener('change', () => {
          p.wyroznione = chkHighlighted.checked;
          markPinUnsaved(p.slug);
          if (p.marker) p.marker.setIcon(createEmojiIcon(p.emoji, p.warstwaId, 32, p));
        });
      }
      const delBtn = container.querySelector('#deleteBtn-' + id);
      if (delBtn) {
        delBtn.addEventListener('click', e => {
          e.stopPropagation();
          openDeleteModal(id);
        });
      }
      const moveBtn = container.querySelector('#movePinBtn-' + id);
      if (moveBtn) {
        moveBtn.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
          startPinReposition(p, container);
        });
      }
      const marker = p.marker || findMarkerByLatLng(lat, lng);
      if (marker) {
        p.marker = marker;
        if (marker._editCloseHandler) {
          marker.off('popupclose', marker._editCloseHandler);
        }
        const onClose = () => {
          delete p._editDraft;
          const popupDiv = document.createElement('div');
          popupDiv.className = 'popup-container';
          popupDiv.innerHTML = createPopupHtml(p);
          marker.bindPopup(popupDiv);
          attachPopupHandlers(marker, p);
          attachMarkerLongPress(marker, p);
          marker.off('popupclose', onClose);
          marker._editCloseHandler = null;
        };
        marker._editCloseHandler = onClose;
        marker.bindPopup(container, {maxWidth: 400, minWidth: 400}).openPopup();
        marker.on('popupclose', onClose);
      }
    }

    function applyPinData(p, data) {
      const staraWarstwa = p.warstwa || "Inne";
      Object.assign(p, data);
      const nowaWarstwa = p.warstwa || "Inne";
      if (!warstwy[nowaWarstwa]) {
        warstwy[nowaWarstwa] = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', defaultVisible: true };
      }
      if (staraWarstwa !== nowaWarstwa) {
        const idx = warstwy[staraWarstwa].lista.indexOf(p);
        if (idx > -1) warstwy[staraWarstwa].lista.splice(idx, 1);
        warstwy[nowaWarstwa].lista.push(p);
        if (p.marker) p.marker.remove();
        const iconEmoji = warstwy[nowaWarstwa].emoji || p.emoji;
        p.marker = L.marker([p.lat, p.lng], {icon: createEmojiIcon(iconEmoji, p.warstwaId, 32, p)}).addTo(warstwy[nowaWarstwa].layer);
        attachMarkerLongPress(p.marker, p);
        attachHighlight(p.marker, p.el);
      } else {
        const iconEmoji = warstwy[nowaWarstwa].emoji || p.emoji;
        if (p.marker) p.marker.setIcon(createEmojiIcon(iconEmoji, p.warstwaId, 32, p));
      }
      if (p.marker) {
        p.marker.setLatLng([p.lat, p.lng]);
      }
      applyInactiveStyle(p);
      const popupDiv = document.createElement("div");
      popupDiv.className = "popup-container";
      popupDiv.innerHTML = createPopupHtml(p);
      p.marker.bindPopup(popupDiv);
      attachPopupHandlers(p.marker, p);
      attachMarkerLongPress(p.marker, p);
      if (p.plany) {
        p.plany.forEach(pl => updatePlanOverlay(p, pl));
      }
    }

    function zapiszLokalnie(id) {
      const nameVal = document.getElementById("enazwa").value.trim();
      const layerVal = document.getElementById("ewarstwa").value.trim();
      const missing = [];
      if (!nameVal) missing.push("Wpisz nazwƒô pinezki");
      if (!layerVal) missing.push("Wybierz warstwƒô");
      if (missing.length) { alert(missing.join("\n")); return; }
      if (layerVal && !warstwy[layerVal]) addLayer(layerVal);
      const catVal = document.getElementById("ekategoria").value.trim();
      if (catVal && !categories.has(catVal)) { categories.add(catVal); updateCategoryFilter(); }
      const p = wszystkiePinezki.find(pp => pp.id === id);
      if (p && p._editDraft) delete p._editDraft;
      const oldData = p ? {
        nazwa: p.nazwa,
        opis: p.opis,
        odKogo: p.odKogo,
        warstwa: p.warstwa,
        warstwaId: p.warstwaId,
        kategoria: p.kategoria,
        emoji: p.emoji,
        trudnosc: p.trudnosc,
        nieaktywne: p.nieaktywne,
        zamkniete: p.zamkniete,
        tajne: p.tajne,
        doSprawdzenia: p.doSprawdzenia,
        zdewastowane: p.zdewastowane,
        zwiedzone: p.zwiedzone,
        wyroznione: p.wyroznione,
        slug: p.slug,
        lat: p.lat,
        lng: p.lng
      } : null;
      const emojiVal = p && p.noweEmoji !== undefined ? p.noweEmoji : (p ? p.emoji : '');
      const nowa = {
        nazwa: nameVal,
        opis: document.getElementById("eopis").value.replace(/\n/g, '<br>'),
        odKogo: document.getElementById("eodKogo").value,
        warstwa: layerVal,
        warstwaId: layerDocs[layerVal] || null,
        kategoria: catVal,
        emoji: emojiVal,
        trudnosc: parseInt(document.getElementById("etrudnosc").value, 10),
        nieaktywne: document.getElementById("enieaktywne").checked,
        zamkniete: document.getElementById("ezamkniete").checked,
        tajne: document.getElementById("etajne").checked,
        doSprawdzenia: document.getElementById("edoSprawdzenia").checked,
        zdewastowane: document.getElementById("ezdewastowane").checked,
        zwiedzone: document.getElementById("ezwiedzone").checked,
        wyroznione: document.getElementById("ewyroznione").checked
      };
      if (p) {
        nowa.lat = p.lat;
        nowa.lng = p.lng;
      }
      zmianyDoZapisania[id] = nowa;
      if (p) {
        const oldSlug = p.slug;
        applyPinData(p, nowa);
        categories.add(p.kategoria || '');
        selectedCategories.add(p.kategoria || '');
        updateCategoryFilter();
        p.slug = slugify(p.nazwa);
        if (oldSlug !== p.slug) {
          const photos = getStoredPhotos(oldSlug);
          delete photosMap[oldSlug];
          storePhotos(p.slug, photos);
        }
        p.unsaved = true;
        const newSlug = p.slug;
        pushAction({
          undo: () => { applyPinData(p, oldData); p.slug = oldData.slug; generujListeWarstw(); updateSaveButton(); },
          redo: () => { applyPinData(p, nowa); p.slug = newSlug; generujListeWarstw(); updateSaveButton(); }
        }, 'Edytowano pinezkƒô');
      }
      generujListeWarstw();
      updateSaveButton();
      map.closePopup();
    }


    async function openNewPinPopup(latlng) {
      await emojiListReady;
      const saveBtnTmp = document.getElementById('saveChanges');
      if (saveBtnTmp) saveBtnTmp.style.display = 'block';
      const defaultEmoji = 'emoji38';
      const marker = L.marker(latlng, {icon: createEmojiIcon(defaultEmoji, null, 24)}).addTo(map);
      pushAction({
        undo: () => map.removeLayer(marker),
        redo: () => marker.addTo(map)
      }, 'Dodano pinezkƒô');
      const newId = crypto.randomUUID();
      const tempPin = {
        id: newId,
        slug: `tmp-${newId}`,
        emoji: defaultEmoji,
        trudnosc: 0
      };
      const container = document.createElement("div");
      container.className = "popup-container edit-popup";
      // Zapobiega zamykaniu popupu przy dotyku na urzƒÖdzeniach mobilnych
      // i umo≈ºliwia poprawne dzia≈Çanie przycisk√≥w wewnƒÖtrz popupu.
      L.DomEvent.disableClickPropagation(container);
      container.innerHTML = `
        <div class="photo-gallery" data-slug="${tempPin.slug}"></div>
        <button class="popup-add-photo" data-slug="${tempPin.slug}">üì∑</button>
        <input id="nazwaNew" placeholder="Nazwa" style="width: 100%"><br>
        <textarea id="opisNew" placeholder="Opis" style="width: 100%; height: 100px"></textarea><br>
        <input id="odKogoNew" placeholder="Od kogo" style="width: 100%"><br>
        <input id="warstwaNew" placeholder="Warstwa" style="width: 102%"><br>
        <input id="kategoriaNew" placeholder="Kategoria" style="width: 102%"><br>
        <div class="trudnosc-wrapper">
          <div class="trudnosc-title">Poziom trudno≈õci</div>
          <input type="range" id="trudnoscNew" class="trudnosc-range" min="0" max="5" step="1" value="0">
          <div class="trudnosc-labels">
            <span>Nieznany</span><span>B.≈Çatwy</span><span>≈Åatwy</span><span>≈öredni</span><span>Trudny</span><span>B.trudny</span>
          </div>
          <div class="trudnosc-value" id="trudnoscNewLabel" style="color:${trudnoscColor(0)}">${trudnoscText(0)}</div>
        </div>
        ${buildStatusGrid('', 'New')}
        <button id="saveNew">üíæ Zapisz</button>
        <button id="cancelNew">Anuluj</button>
        <div id="emojiPickerNew" class="emoji-picker"></div>`;

      setupGallery(container.querySelector('.photo-gallery'));
      setupAddPhotoButton(container.querySelector('.popup-add-photo'), tempPin.slug, container.querySelector('.photo-gallery'));
      setupEmojiPicker(container.querySelector('#emojiPickerNew'), tempPin);
      setupDropdownInput(container.querySelector('#warstwaNew'), () => Object.keys(warstwy));
      setupDropdownInput(container.querySelector('#kategoriaNew'), () => Array.from(categories).filter(c => c));
      setupTrudnoscInput(container.querySelector('#trudnoscNew'), container.querySelector('#trudnoscNewLabel'));

      const popup = marker.bindPopup(container).openPopup();
      attachHighlight(marker, null);

      const chkNewInactive = container.querySelector('#nieaktywneNew');
      const chkNewClosed = container.querySelector('#zamknieteNew');
      const chkNewSecret = container.querySelector('#tajneNew');
      const chkNewTodo = container.querySelector('#doSprawdzeniaNew');
      const chkNewDestroyed = container.querySelector('#zdewastowaneNew');
      const chkNewVisited = container.querySelector('#zwiedzoneNew');
      const chkNewHighlighted = container.querySelector('#wyroznioneNew');
      const refreshIcon = () => {
        const status = {
          nieaktywne: chkNewInactive && chkNewInactive.checked,
          zamkniete: chkNewClosed && chkNewClosed.checked,
          tajne: chkNewSecret && chkNewSecret.checked,
          doSprawdzenia: chkNewTodo && chkNewTodo.checked,
          zdewastowane: chkNewDestroyed && chkNewDestroyed.checked,
          zwiedzone: chkNewVisited && chkNewVisited.checked,
          wyroznione: chkNewHighlighted && chkNewHighlighted.checked
        };
        const emojiVal = tempPin.noweEmoji !== undefined ? tempPin.noweEmoji : tempPin.emoji || defaultEmoji;
        marker.setIcon(createEmojiIcon(emojiVal, null, 24, status));
      };
      container.querySelector('#emojiPickerNew').addEventListener('click', () => setTimeout(refreshIcon, 0));
      if (chkNewInactive) {
        chkNewInactive.addEventListener('change', () => {
          const tmp = { marker, el: null, nieaktywne: chkNewInactive.checked };
          applyInactiveStyle(tmp);
          refreshIcon();
        });
      }
      if (chkNewClosed) chkNewClosed.addEventListener('change', refreshIcon);
      if (chkNewSecret) chkNewSecret.addEventListener('change', refreshIcon);
      if (chkNewTodo) chkNewTodo.addEventListener('change', refreshIcon);
      if (chkNewDestroyed) chkNewDestroyed.addEventListener('change', refreshIcon);
      if (chkNewVisited) chkNewVisited.addEventListener('change', refreshIcon);
      if (chkNewHighlighted) chkNewHighlighted.addEventListener('change', refreshIcon);

      let saved = false;
      const removeOnClose = () => {
        if (!saved && map.hasLayer(marker)) {
          map.removeLayer(marker);
        }
        marker.off('popupclose', removeOnClose);
        if (!saved) updateSaveButton();
      };
      marker.on('popupclose', removeOnClose);

        container.querySelector("#saveNew").addEventListener("click", (e) => {
          e.stopPropagation();
          const nameVal = container.querySelector("#nazwaNew").value.trim();
          const layerVal = container.querySelector("#warstwaNew").value.trim();
          const missing = [];
          if (!nameVal) missing.push("Wpisz nazwƒô pinezki");
          if (!layerVal) missing.push("Wybierz warstwƒô");
          if (missing.length) { alert(missing.join("\n")); return; }
          if (layerVal && !warstwy[layerVal]) addLayer(layerVal);
          const catVal = container.querySelector("#kategoriaNew").value.trim();
          if (catVal && !categories.has(catVal)) { categories.add(catVal); updateCategoryFilter(); }
          const data = {
            id: tempPin.id,
            IDpinezki: tempPin.id,
            nazwa: nameVal,
            opis: container.querySelector("#opisNew").value.replace(/\n/g, '<br>'),
            warstwa: layerVal,
            kategoria: catVal,
            emoji: tempPin.noweEmoji !== undefined ? tempPin.noweEmoji : tempPin.emoji,
            nieaktywne: container.querySelector("#nieaktywneNew").checked,
            zamkniete: container.querySelector("#zamknieteNew").checked,
            tajne: container.querySelector("#tajneNew").checked,
            doSprawdzenia: container.querySelector("#doSprawdzeniaNew").checked,
            zdewastowane: container.querySelector("#zdewastowaneNew").checked,
            zwiedzone: container.querySelector("#zwiedzoneNew").checked,
            wyroznione: container.querySelector("#wyroznioneNew").checked,
            odKogo: container.querySelector("#odKogoNew").value,
            trudnosc: parseInt(container.querySelector("#trudnoscNew").value, 10),
            lat: latlng.lat,
            lng: latlng.lng,
            dataDodania: Date.now(),
            unsaved: true,
            firebaseId: null
          };
        saved = true;

        const warstwaN = data.warstwa || "Inne";
        data.warstwaId = layerDocs[warstwaN] || null;
        if (!warstwy[warstwaN]) {
          warstwy[warstwaN] = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', loaded: true, loading: false, defaultVisible: true };
        }
        data.marker = marker;
        const iconEmoji = warstwy[warstwaN].emoji || data.emoji;
        marker.setIcon(createEmojiIcon(iconEmoji, data.warstwaId, 32, data));
        applyInactiveStyle(data);
        const oldSlug = tempPin.slug;
        data.slug = slugify(data.nazwa);
        if (oldSlug !== data.slug) {
          const photos = getStoredPhotos(oldSlug);
          delete photosMap[oldSlug];
          storePhotos(data.slug, photos);
        } else if (!photosMap[data.slug]) {
          storePhotos(data.slug, []);
        }
        categories.add(data.kategoria || '');
        selectedCategories.add(data.kategoria || '');
        updateCategoryFilter();
        const popupDiv = document.createElement('div');
        popupDiv.className = 'popup-container';
        popupDiv.innerHTML = createPopupHtml(data);
        marker.bindPopup(popupDiv);
        attachPopupHandlers(marker, data);
        attachMarkerLongPress(marker, data);

        nowePinezki.push(data);
        localStorage.setItem('nowePinezki', JSON.stringify(nowePinezki.map(p => {
          const {marker, ...rest} = p;
          return rest;
        })));
        warstwy[warstwaN].lista.push(data);
        wszystkiePinezki.push(data);
        generujListeWarstw();
        updateSaveButton();
        map.closePopup();
      });

      container.querySelector("#cancelNew").addEventListener("click", (e) => {
        e.stopPropagation();
        map.closePopup();
      });
    }
    async function onMapClick(e) {
      await openNewPinPopup(e.latlng);
      selectTool('hand');
    }

    function findMarkerByLatLng(lat, lng) {
      for (const layer of Object.values(map._layers)) {
        if (
  layer.getLatLng &&
  Math.abs(layer.getLatLng().lat - lat) < 1e-6 &&
  Math.abs(layer.getLatLng().lng - lng) < 1e-6
) {
          return layer;
        }
      }
      return null;
    }

    function loadLayerOrder() {
      try {
        return JSON.parse(localStorage.getItem(LAYER_ORDER_STORAGE_KEY)) || [];
      } catch (e) {
        return [];
      }
    }

    function loadLayerCollapseStates() {
      try {
        const stored = JSON.parse(localStorage.getItem(LAYER_COLLAPSE_STORAGE_KEY));
        if (stored && typeof stored === 'object') {
          return stored;
        }
      } catch (e) {}
      return {};
    }

    function saveLayerCollapseStates(states) {
      localStorage.setItem(LAYER_COLLAPSE_STORAGE_KEY, JSON.stringify(states));
    }

    function setLayerCollapseState(name, collapsed) {
      const states = loadLayerCollapseStates();
      states[name] = !!collapsed;
      saveLayerCollapseStates(states);
    }

    function removeLayerCollapseState(name) {
      const states = loadLayerCollapseStates();
      if (name in states) {
        delete states[name];
        saveLayerCollapseStates(states);
      }
    }

    function persistAllLayerCollapseStates() {
      const states = {};
      Object.keys(warstwy).forEach(name => {
        states[name] = !!warstwy[name].collapsed;
      });
      saveLayerCollapseStates(states);
    }

    function loadLayerVisibilityStates() {
      try {
        const stored = JSON.parse(localStorage.getItem(LAYER_VISIBILITY_STORAGE_KEY));
        if (stored && typeof stored === 'object') {
          return stored;
        }
      } catch (e) {}
      return {};
    }

    function saveLayerVisibilityStates(states) {
      localStorage.setItem(LAYER_VISIBILITY_STORAGE_KEY, JSON.stringify(states));
    }

    function setLayerVisibilityState(name, visible) {
      if (!name) return;
      const states = loadLayerVisibilityStates();
      states[name] = !!visible;
      saveLayerVisibilityStates(states);
    }

    function removeLayerVisibilityState(name) {
      if (!name) return;
      const states = loadLayerVisibilityStates();
      if (name in states) {
        delete states[name];
        saveLayerVisibilityStates(states);
      }
    }

    function persistAllLayerVisibilityStates() {
      const states = {};
      Object.keys(warstwy).forEach(name => {
        if (!warstwy[name].temporary) {
          states[name] = !!warstwy[name].visible;
        }
      });
      saveLayerVisibilityStates(states);
    }

    function getLayerDefaultVisible(name) {
      const layer = warstwy[name];
      if (!layer) return true;
      if (layer.defaultVisible === undefined || layer.defaultVisible === null) return true;
      return !!layer.defaultVisible;
    }

    function applyLayerDefaultState(name) {
      if (!warstwy[name]) return;
      const defaultVisible = getLayerDefaultVisible(name);
      warstwy[name].visible = defaultVisible;
      warstwy[name].collapsed = !defaultVisible;
      if (defaultVisible) {
        warstwy[name].layer.addTo(map);
      } else {
        map.removeLayer(warstwy[name].layer);
      }
    }

    function saveLayerOrder({ markChange = true } = {}) {
      const order = Array.from(document.querySelectorAll('#lista-warstw .warstwa'))
        .map(el => el.dataset.nazwa)
        .filter(n => !warstwy[n] || !warstwy[n].temporary);
      const prev = loadLayerOrder();
      localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(order));
      if (markChange && JSON.stringify(prev) !== JSON.stringify(order)) {
        layerOrderChanged = JSON.stringify(order) !== JSON.stringify(initialLayerOrder);
        updateSaveButton();
      }
    }

    function updateLayerNumbers() {
      document.querySelectorAll('#lista-warstw .warstwa').forEach((div, idx) => {
        const num = div.querySelector('.layer-number');
        if (num) num.textContent = idx + 1;
      });
    }

    function loadNewPinsFromLocal() {
      try {
        nowePinezki = JSON.parse(localStorage.getItem('nowePinezki')) || [];
      } catch (e) {
        nowePinezki = [];
      }
      localPinsLoaded = true;
      let changed = false;
      nowePinezki.forEach(p => {
        if (!p.IDpinezki) { p.IDpinezki = crypto.randomUUID(); changed = true; }
        if (!p.id) { p.id = p.IDpinezki; changed = true; }
        if (p.firebaseId === undefined) p.firebaseId = null;
        p.unsaved = true;
        if (p.nieaktywne === undefined) p.nieaktywne = false;
        if (p.zamkniete === undefined) p.zamkniete = false;
        if (p.tajne === undefined) p.tajne = false;
        if (p.doSprawdzenia === undefined) p.doSprawdzenia = false;
        if (p.zdewastowane === undefined) p.zdewastowane = false;
        if (p.zwiedzone === undefined) p.zwiedzone = false;
        if (p.wyroznione === undefined) p.wyroznione = false;
        if (!p.slug) p.slug = slugify(p.nazwa);
        if (!p.dataDodania) p.dataDodania = Date.now();
        categories.add(p.kategoria || '');
        selectedCategories.add(p.kategoria || '');
        const layerInfo = resolveLayerInfo(p.warstwa, p.warstwaId);
        p.warstwaId = layerInfo.warstwaId || null;
        p.warstwa = layerInfo.warstwaName;
        const warstwaN = p.warstwa || 'Inne';
        if (!warstwy[warstwaN]) {
          warstwy[warstwaN] = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', loaded: true, loading: false, defaultVisible: true };
        }
        const iconEmoji = warstwy[warstwaN].emoji || p.emoji;
        const marker = L.marker([p.lat, p.lng], {icon: createEmojiIcon(iconEmoji, p.warstwaId, 32, p)}).addTo(warstwy[warstwaN].layer);
        if (p.trasy) {
          p.trasy.forEach(tr => {
            const color = tr.kolor || DEFAULT_ROUTE_COLOR;
            const opacity = getRouteOpacity(tr);
            tr.przezroczystosc = opacity;
            const layer = L.polyline(tr.punkty.map(pt => [pt.lat, pt.lng]), {color, weight:4, className:'route-line', opacity}).addTo(rysowaneTrasy);
            tr.layer = layer;
            layer.on('click', e => showRoutePopup(p.id, tr, e.latlng));
          });
        } else {
          p.trasy = [];
        }
        const popupDiv = document.createElement('div');
        popupDiv.className = 'popup-container';
        popupDiv.innerHTML = createPopupHtml(p);
        marker.bindPopup(popupDiv);
        attachPopupHandlers(marker, p);
        attachMarkerLongPress(marker, p);
        attachHighlight(marker, null);
        p.marker = marker;
        applyInactiveStyle(p);
        warstwy[warstwaN].lista.push(p);
        wszystkiePinezki.push(p);
      });
      if (changed) localStorage.setItem('nowePinezki', JSON.stringify(nowePinezki.map(p => {
        const {marker, ...rest} = p;
        return rest;
      })));
      updateSaveButton();
      updateCategoryFilter();
    }

    function setupDrag(div, handle) {
      handle.draggable = true;
      handle.addEventListener('dragstart', () => {
        draggedLayer = div;
        handle.classList.add('dragging');
      });
      handle.addEventListener('dragend', () => {
        handle.classList.remove('dragging');
        draggedLayer = null;
      });
      div.addEventListener('dragover', e => e.preventDefault());
      div.addEventListener('drop', e => {
        e.preventDefault();
        if (draggedLayer && draggedLayer !== div) {
          const lista = document.getElementById('lista-warstw');
          lista.insertBefore(draggedLayer, div);
          saveLayerOrder();
          updateLayerNumbers();
        }
      });
    }

    function handlePinSelectionClick(event, pin, el) {
      const isShift = event.shiftKey;
      const isToggle = event.ctrlKey || event.metaKey;
      const pinId = String(pin.id);
      if (isShift || isToggle) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (isShift && lastSelectedPinId) {
        const allItems = Array.from(document.querySelectorAll('#lista-warstw .pinezka'));
        const currentIndex = allItems.indexOf(el);
        const lastIndex = allItems.findIndex(item => item.dataset.pinId === lastSelectedPinId);
        if (currentIndex !== -1 && lastIndex !== -1) {
          if (!isToggle) selectedPinIds.clear();
          const [start, end] = currentIndex < lastIndex ? [currentIndex, lastIndex] : [lastIndex, currentIndex];
          for (let i = start; i <= end; i++) {
            const itemId = allItems[i].dataset.pinId;
            if (itemId) selectedPinIds.add(itemId);
          }
          lastSelectedPinId = pinId;
          updateSelectionStyles();
          updateBulkPanel();
          return true;
        }
      }
      if (isToggle) {
        if (selectedPinIds.has(pinId)) {
          selectedPinIds.delete(pinId);
        } else {
          selectedPinIds.add(pinId);
        }
        lastSelectedPinId = pinId;
        updateSelectionStyles();
        updateBulkPanel();
        return true;
      }
      selectedPinIds.clear();
      selectedPinIds.add(pinId);
      lastSelectedPinId = pinId;
      updateSelectionStyles();
      updateBulkPanel();
      return false;
    }

    function highlightListItem(el) {
      if (highlightedItem) {
        highlightedItem.classList.remove('active');
      }
      highlightedItem = el;
      if (highlightedItem) {
        highlightedItem.classList.add('active');
        highlightedItem.scrollIntoView({behavior: 'smooth', block: 'nearest'});
      }
    }

    function setMarkerHighlight(marker) {
      if (!map || !marker) return;
      const latlng = marker.getLatLng();
      if (!latlng) return;

      const iconOptions = marker.options.icon?.options || {};
      const iconSizePoint = L.point(iconOptions.iconSize || [32, 32]);
      const iconAnchorPoint = L.point(iconOptions.iconAnchor || [iconSizePoint.x / 2, iconSizePoint.y / 2]);
      const markerPoint = map.latLngToLayerPoint(latlng);
      const centerPoint = markerPoint.subtract(
        L.point(iconAnchorPoint.x - iconSizePoint.x / 2, iconAnchorPoint.y - iconSizePoint.y / 2)
      );
      const iconCenterLatLng = map.layerPointToLatLng(centerPoint);
      const radius = Math.max(iconSizePoint.x, iconSizePoint.y) * 0.6;

      highlightedMarker = marker;

      if (!pinHighlightCircle) {
        pinHighlightCircle = L.circleMarker(iconCenterLatLng, {
          radius,
          color: '#ffffff',
          weight: 4,
          opacity: 0.2,
          fillColor: '#ffffff',
          fillOpacity: 0.5,
          pane: 'pinHighlightPane',
          interactive: false
        }).addTo(map);
      } else {
        pinHighlightCircle.setLatLng(iconCenterLatLng);
        pinHighlightCircle.setStyle({ radius, weight: 4 });
        if (!map.hasLayer(pinHighlightCircle)) {
          pinHighlightCircle.addTo(map);
        }
      }
    }

    function clearMarkerHighlight(marker) {
      if (marker && marker !== highlightedMarker) return;
      if (map && pinHighlightCircle && map.hasLayer(pinHighlightCircle)) {
        map.removeLayer(pinHighlightCircle);
      }
      if (!marker || marker === highlightedMarker) {
        highlightedMarker = null;
      }
    }

    function attachHighlight(marker, el) {
      if (!marker) return;
      if (marker._highlightHandler) {
        marker.off('click', marker._highlightHandler);
      }
      marker._highlightHandler = () => {
        if (drawingRoute) return;
        marker.openPopup();
      };
      marker.on('click', marker._highlightHandler);

      if (marker._highlightPopupHandler) {
        marker.off('popupopen', marker._highlightPopupHandler);
      }
      marker._highlightPopupHandler = () => {
        setMarkerHighlight(marker);
        if (el) highlightListItem(el);
      };
      marker.on('popupopen', marker._highlightPopupHandler);

      if (marker._highlightCloseHandler) {
        marker.off('popupclose', marker._highlightCloseHandler);
      }
      marker._highlightCloseHandler = () => {
        clearMarkerHighlight(marker);
      };
      marker.on('popupclose', marker._highlightCloseHandler);

      if (marker._highlightRemoveHandler) {
        marker.off('remove', marker._highlightRemoveHandler);
      }
      marker._highlightRemoveHandler = () => {
        clearMarkerHighlight(marker);
      };
      marker.on('remove', marker._highlightRemoveHandler);
    }

    function attachMarkerLongPress(marker, pin) {
      if (!marker || !pin) return;
      if (marker._longPressHandlers) {
        const { start, cancel, end, dragEnd, dragStart } = marker._longPressHandlers;
        marker.off('mousedown', start);
        marker.off('touchstart', start);
        marker.off('mouseup', end);
        marker.off('touchend', end);
        marker.off('mouseout', cancel);
        marker.off('touchcancel', cancel);
        marker.off('dragend', dragEnd);
        marker.off('dragstart', dragStart);
      }

      const state = {
        timer: null,
        active: false,
        draggingStarted: false,
        originalEvent: null
      };

      const clearTimer = () => {
        if (state.timer) {
          clearTimeout(state.timer);
          state.timer = null;
        }
      };

      const stopLongPress = () => {
        if (marker.dragging && typeof marker.dragging.enabled === 'function' && marker.dragging.enabled()) {
          marker.dragging.disable();
        }
        state.active = false;
        state.draggingStarted = false;
        state.originalEvent = null;
      };

      const startHandler = e => {
        if (drawingRoute) return;
        state.originalEvent = e.originalEvent;
        clearTimer();
        state.timer = setTimeout(() => {
          state.timer = null;
          state.active = true;
          state.draggingStarted = false;
          if (marker.dragging && typeof marker.dragging.enable === 'function') {
            marker.dragging.enable();
            if (state.originalEvent && marker.dragging._draggable && marker.dragging._draggable._onDown) {
              if (state.originalEvent.preventDefault) state.originalEvent.preventDefault();
              marker.dragging._draggable._onDown(state.originalEvent);
            }
          }
        }, 3000);
      };

      const cancelHandler = e => {
        if (state.active) {
          if (e && e.type === 'touchcancel') {
            stopLongPress();
          }
          return;
        }
        clearTimer();
        stopLongPress();
      };

      const endHandler = () => {
        if (!state.active) {
          clearTimer();
          return;
        }
        if (!state.draggingStarted) {
          stopLongPress();
        }
      };

      const dragStartHandler = () => {
        state.draggingStarted = true;
      };

      const dragEndHandler = () => {
        clearTimer();
        if (!state.active) {
          stopLongPress();
          return;
        }
        const moved = state.draggingStarted;
        stopLongPress();
        if (!moved) return;
        const { lat, lng } = marker.getLatLng();
        pin.lat = lat;
        pin.lng = lng;
        markPinUnsaved(pin.slug);
        const cur = zmianyDoZapisania[pin.id] || {};
        cur.lat = lat;
        cur.lng = lng;
        zmianyDoZapisania[pin.id] = cur;
        if (!pin.firebaseId) {
          localStorage.setItem('nowePinezki', JSON.stringify(nowePinezki.map(np => {
            const { marker: npMarker, ...rest } = np;
            return rest;
          })));
        }
        const popupDiv = document.createElement('div');
        popupDiv.className = 'popup-container';
        popupDiv.innerHTML = createPopupHtml(pin);
        marker.bindPopup(popupDiv);
        attachPopupHandlers(marker, pin);
        updateSaveButton();
      };

      marker.on('mousedown', startHandler);
      marker.on('touchstart', startHandler);
      marker.on('mouseout', cancelHandler);
      marker.on('touchcancel', cancelHandler);
      marker.on('mouseup', endHandler);
      marker.on('touchend', endHandler);
      marker.on('dragstart', dragStartHandler);
      marker.on('dragend', dragEndHandler);

      marker._longPressHandlers = {
        start: startHandler,
        cancel: cancelHandler,
        end: endHandler,
        dragEnd: dragEndHandler,
        dragStart: dragStartHandler
      };
    }

    function applyInactiveStyle(p) {
      if (p.marker) {
        p.marker.setOpacity(1);
        const el = p.marker.getElement();
        if (el) el.style.filter = p.nieaktywne ? 'saturate(50%)' : '';
      }
      if (p.el) {
        if (p.nieaktywne) {
          p.el.classList.add('inactive');
        } else {
          p.el.classList.remove('inactive');
        }
      }
    }

    function startRouteDrawing(pin) {
      drawingRoute = true;
      activeRoutePin = pin;
      const opts = {shapeOptions: {color: DEFAULT_ROUTE_COLOR, weight: 4, className: 'route-line', opacity: DEFAULT_ROUTE_OPACITY}};
      const dh = new L.Draw.Polyline(map, opts);
      dh.enable();
    }

    function onRouteCreated(e) {
      if (!activeRoutePin) return;
      const layer = e.layer;
      rysowaneTrasy.addLayer(layer);
      const latlngs = layer.getLatLngs().map(pt => ({lat: pt.lat, lng: pt.lng}));
      if (!activeRoutePin.trasy) activeRoutePin.trasy = [];
      const name = 'trasa ' + (activeRoutePin.trasy.length + 1);
      const tr = {nazwa: name, opis: '', kolor: DEFAULT_ROUTE_COLOR, punkty: latlngs, przezroczystosc: DEFAULT_ROUTE_OPACITY, layer};
      layer.setStyle({color: tr.kolor || DEFAULT_ROUTE_COLOR, opacity: getRouteOpacity(tr)});
      activeRoutePin.trasy.push(tr);
      layer.on('click', ev => showRoutePopup(activeRoutePin.id, tr, ev.latlng));
      window.localTrasy.push({action: 'add', pinId: activeRoutePin.id});
      zmianyDoZapisania[activeRoutePin.id] = Object.assign(zmianyDoZapisania[activeRoutePin.id] || {}, {
        trasy: activeRoutePin.trasy.map(t => serializeRoute(t))
      });
      updateSaveButton();
      generujListeWarstw();
    }

    function renameLayer(oldName, labelEl) {
      const input = document.createElement('input');
      input.type = 'text';
      input.value = oldName;
      labelEl.replaceWith(input);
      input.focus();
      input.select();

      function finish() {
        const newName = input.value.trim();
        applyRenameLayer(oldName, newName);
        generujListeWarstw();
        updateSaveButton();
        input.replaceWith(labelEl);
      }

      input.onblur = finish;
      input.onkeydown = e => {
        if (e.key === 'Enter') {
          input.blur();
        } else if (e.key === 'Escape') {
          input.value = oldName;
          input.blur();
        }
      };
    }

    function addLayer(name, record = true) {
      if (!name || warstwy[name]) return;
      const prevLayersToAdd = layersToAdd.slice();
      const prevOrder = loadLayerOrder();
      warstwy[name] = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', defaultVisible: true };
      warstwy[name].visible = true;
      setLayerCollapseState(name, true);
      setLayerVisibilityState(name, true);
      layersToAdd.push(name);
      const order = prevOrder.slice();
      order.unshift(name);
      localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(order));
      generujListeWarstw();
      updateSaveButton();
      if (record) {
        pushAction({
          undo: () => {
            if (warstwy[name]) {
              map.removeLayer(warstwy[name].layer);
              delete warstwy[name];
            }
            layersToAdd = prevLayersToAdd;
            localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(prevOrder));
            removeLayerCollapseState(name);
            removeLayerVisibilityState(name);
            generujListeWarstw();
            updateSaveButton();
          },
          redo: () => {
            warstwy[name] = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', defaultVisible: true };
            warstwy[name].visible = true;
            layersToAdd = prevLayersToAdd.concat(name);
            const o = prevOrder.slice();
            o.unshift(name);
            localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(o));
            setLayerCollapseState(name, true);
            setLayerVisibilityState(name, true);
            generujListeWarstw();
            updateSaveButton();
          }
        }, `Dodano warstwƒô ${name}`);
      }
    }

    function deleteLayer(name, record = true) {
      if (!warstwy[name]) return;
      const layerData = warstwy[name];
      const pins = layerData.lista.slice();
      const prevOrder = loadLayerOrder();
      const prevLayersToDelete = layersToDelete.slice();
      const prevLayersToAdd = layersToAdd.slice();
      const prevPinsToDelete = pinsToDelete.slice();
      const prevZmiany = Object.assign({}, zmianyDoZapisania);
      const prevNowe = nowePinezki.slice();
      layerData.lista.forEach(p => {
        if (p.firebaseId) pinsToDelete.push({ id: p.id, firebaseId: p.firebaseId });
        const idxN = nowePinezki.indexOf(p);
        if (idxN > -1) nowePinezki.splice(idxN, 1);
        delete zmianyDoZapisania[p.id];
        if (p.marker) map.removeLayer(p.marker);
      });
      wszystkiePinezki = wszystkiePinezki.filter(pp => pp.warstwa !== name);
      map.removeLayer(layerData.layer);
      delete warstwy[name];
      removeLayerCollapseState(name);
      removeLayerVisibilityState(name);
      layersToDelete.push(name);
      const order = loadLayerOrder().filter(n => n !== name);
      localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(order));
      generujListeWarstw();
      updateSaveButton();
      if (record) {
        pushAction({
          undo: () => {
            warstwy[name] = layerData;
            const wasVisible = layerData.visible !== false;
            warstwy[name].visible = wasVisible;
            if (wasVisible) {
              layerData.layer.addTo(map);
            }
            warstwy[name].lista.forEach(p => { if (p.marker) p.marker.addTo(layerData.layer); });
            wszystkiePinezki.push(...pins);
            layersToDelete = prevLayersToDelete;
            layersToAdd = prevLayersToAdd;
            pinsToDelete = prevPinsToDelete;
            zmianyDoZapisania = Object.assign({}, prevZmiany);
            nowePinezki = prevNowe;
            localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(prevOrder));
            setLayerCollapseState(name, layerData.collapsed);
            setLayerVisibilityState(name, wasVisible);
            generujListeWarstw();
            updateSaveButton();
          },
          redo: () => {
            deleteLayer(name, false);
          }
        }, `Usuniƒôto warstwƒô ${name}`);
      }
    }

    function confirmDeleteLayer(name) {
      openLayerDeleteModal(name);
    }
    let editedLayer = null;
    function showLayerEditor(name) {
      const panel = document.getElementById('layer-editor');
      if (!panel) return;
      editedLayer = name;
      document.getElementById('layerEditName').value = name;
      const order = loadLayerOrder();
      const idx = order.indexOf(name);
      document.getElementById('layerEditOrder').value = idx >= 0 ? idx + 1 : (order.length + 1);
      document.getElementById('layerEditEmoji').value = warstwy[name].emoji || '';
      const defaultVisible = getLayerDefaultVisible(name);
      const defaultVisibleInput = document.getElementById('layerDefaultVisible');
      const defaultHiddenInput = document.getElementById('layerDefaultHidden');
      if (defaultVisibleInput && defaultHiddenInput) {
        defaultVisibleInput.checked = defaultVisible;
        defaultHiddenInput.checked = !defaultVisible;
      }
      panel.style.display = 'block';
    }

    function closeLayerEditor() {
      const panel = document.getElementById('layer-editor');
      if (panel) panel.style.display = 'none';
    }

    function applyLayerEdits() {
      const oldState = {
        name: editedLayer,
        order: loadLayerOrder(),
        emoji: warstwy[editedLayer].emoji || '',
        defaultVisible: getLayerDefaultVisible(editedLayer)
      };
      const newName = document.getElementById('layerEditName').value.trim();
      const newOrder = parseInt(document.getElementById('layerEditOrder').value, 10);
      const newEmoji = document.getElementById('layerEditEmoji').value.trim();
      const defaultVisibleInput = document.getElementById('layerDefaultVisible');
      const defaultHiddenInput = document.getElementById('layerDefaultHidden');
      if (!defaultVisibleInput || !defaultHiddenInput || (!defaultVisibleInput.checked && !defaultHiddenInput.checked)) {
        showToast('Wybierz domy≈õlnƒÖ widoczno≈õƒá warstwy.');
        return;
      }
      const newDefaultVisible = defaultVisibleInput.checked;
      if (newName && newName !== editedLayer) {
        applyRenameLayer(editedLayer, newName);
        editedLayer = newName;
      }
      reorderLayer(editedLayer, newOrder);
      if (warstwy[editedLayer].emoji !== newEmoji) {
        warstwy[editedLayer].emoji = newEmoji;
        layerEmojiChanges[editedLayer] = newEmoji;
        updateMarkersForLayer(editedLayer);
      }
      if (getLayerDefaultVisible(editedLayer) !== newDefaultVisible) {
        warstwy[editedLayer].defaultVisible = newDefaultVisible;
        layerDefaultVisibilityChanges[editedLayer] = newDefaultVisible;
      }
      generujListeWarstw();
      updateSaveButton();
      closeLayerEditor();
      const newState = {
        name: editedLayer,
        order: loadLayerOrder(),
        emoji: warstwy[editedLayer].emoji || '',
        defaultVisible: getLayerDefaultVisible(editedLayer)
      };
      pushAction({
        undo: () => {
          if (newState.name !== oldState.name) applyRenameLayer(newState.name, oldState.name);
          reorderLayer(oldState.name, oldState.order.indexOf(oldState.name) + 1);
          if (warstwy[oldState.name].emoji !== oldState.emoji) {
            warstwy[oldState.name].emoji = oldState.emoji;
            updateMarkersForLayer(oldState.name);
          }
          warstwy[oldState.name].defaultVisible = oldState.defaultVisible;
          generujListeWarstw();
          updateSaveButton();
        },
        redo: () => {
          if (newState.name !== oldState.name) applyRenameLayer(oldState.name, newState.name);
          reorderLayer(newState.name, newState.order.indexOf(newState.name) + 1);
          if (warstwy[newState.name].emoji !== newState.emoji) {
            warstwy[newState.name].emoji = newState.emoji;
            updateMarkersForLayer(newState.name);
          }
          warstwy[newState.name].defaultVisible = newState.defaultVisible;
          generujListeWarstw();
          updateSaveButton();
        }
      }, 'Edytowano warstwƒô ' + newState.name);
    }

    function applyRenameLayer(oldName, newName) {
      if (!newName || newName === oldName) return;
      if (warstwy[newName]) {
        alert('Warstwa o takiej nazwie ju≈º istnieje.');
        return;
      }
      const layer = warstwy[oldName];
      if (!layer) return;
      layer.lista.forEach(p => {
        const cur = zmianyDoZapisania[p.id] || {};
        cur.warstwa = newName;
        cur.warstwaId = layerDocs[newName] || p.warstwaId || null;
        zmianyDoZapisania[p.id] = cur;
        p.warstwa = newName;
        p.warstwaId = cur.warstwaId;
        p.unsaved = true;
      });
      warstwy[newName] = layer;
      delete warstwy[oldName];
      if (!layersToAdd.includes(newName) && !layerDocs[newName]) layersToAdd.push(newName);
      if (!layersToDelete.includes(oldName) && (layerDocs[oldName] || layersToAdd.includes(oldName))) layersToDelete.push(oldName);
      const order = loadLayerOrder().map(n => n === oldName ? newName : n);
      localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(order));
      const collapseStates = loadLayerCollapseStates();
      if (collapseStates.hasOwnProperty(oldName)) {
        collapseStates[newName] = collapseStates[oldName];
        delete collapseStates[oldName];
        saveLayerCollapseStates(collapseStates);
      }
      const visibilityStates = loadLayerVisibilityStates();
      if (visibilityStates.hasOwnProperty(oldName)) {
        visibilityStates[newName] = visibilityStates[oldName];
        delete visibilityStates[oldName];
        saveLayerVisibilityStates(visibilityStates);
      }
    }

    function reorderLayer(name, newPos) {
      let order = loadLayerOrder().filter(n => n !== name);
      newPos = Math.max(1, Math.min(newPos, order.length + 1));
      order.splice(newPos - 1, 0, name);
      localStorage.setItem(LAYER_ORDER_STORAGE_KEY, JSON.stringify(order));
      layerOrderChanged = JSON.stringify(order) !== JSON.stringify(initialLayerOrder);
      updateSaveButton();
    }

    function updateMarkersForLayer(name) {
      const layer = warstwy[name];
      if (!layer) return;
      layer.lista.forEach(p => {
        const emoji = layer.emoji || p.emoji;
        if (p.marker) p.marker.setIcon(createEmojiIcon(emoji, p.warstwaId, 32, p));
        if (p.el) p.el.innerHTML = (emoji ? emojiHtml(emoji) + ' ' : '') + p.nazwa;
      });
    }

    function initLayerEditor() {
      const panel = document.getElementById('layer-editor');
      if (!panel) return;
      const closeBtn = document.getElementById('layerEditClose');
      const saveBtn = document.getElementById('layerEditSave');
      const delBtn = document.getElementById('layerEditDelete');
      const orderInput = document.getElementById('layerEditOrder');
      const emojiInput = document.getElementById('layerEditEmoji');
      setupEmojiInput(emojiInput);

      closeBtn.addEventListener('click', e => {
        e.preventDefault();
        e.stopPropagation();
        closeLayerEditor();
      });
      saveBtn.addEventListener('click', e => {
        e.preventDefault();
        e.stopPropagation();
        applyLayerEdits();
      });
      orderInput.addEventListener('change', e => {
        const val = parseInt(orderInput.value, 10);
        if (!isNaN(val) && editedLayer) {
          reorderLayer(editedLayer, val);
          generujListeWarstw();
          orderInput.value = val;
        }
      });
      delBtn.addEventListener('click', e => {
        e.preventDefault();
        e.stopPropagation();
        panel.style.display = 'none';
        confirmDeleteLayer(editedLayer);
      });
    }

    let editedRoute = null;

    function normalizeRouteOpacity(value) {
      const num = typeof value === 'string' ? parseFloat(value) : value;
      if (Number.isNaN(num)) return DEFAULT_ROUTE_OPACITY;
      return Math.min(1, Math.max(0, num));
    }

    function getRouteOpacity(tr) {
      if (!tr) return DEFAULT_ROUTE_OPACITY;
      return normalizeRouteOpacity(tr.przezroczystosc !== undefined ? tr.przezroczystosc : DEFAULT_ROUTE_OPACITY);
    }

    function serializeRoute(tr) {
      return {
        nazwa: tr.nazwa,
        opis: tr.opis || '',
        kolor: tr.kolor || DEFAULT_ROUTE_COLOR,
        punkty: tr.punkty,
        przezroczystosc: getRouteOpacity(tr)
      };
    }

    function updateRouteOpacityLabel(value) {
      const label = document.getElementById('routeEditOpacityValue');
      if (!label) return;
      const percent = Math.round(value);
      label.textContent = `${percent}%`;
    }
    function showRouteEditor(pinId, idx) {
      const panel = document.getElementById('route-editor');
      if (!panel) return;
      const pin = wszystkiePinezki.find(p => p.id === pinId);
      if (!pin || !pin.trasy || !pin.trasy[idx]) return;
      editedRoute = {pinId, idx};
      document.getElementById('routeEditName').value = pin.trasy[idx].nazwa;
      document.getElementById('routeEditDesc').value = pin.trasy[idx].opis || '';
      document.getElementById('routeEditColor').value = pin.trasy[idx].kolor || DEFAULT_ROUTE_COLOR;
      const opacityInput = document.getElementById('routeEditOpacity');
      if (opacityInput) {
        const opacityValue = Math.round(getRouteOpacity(pin.trasy[idx]) * 100);
        opacityInput.value = opacityValue;
        updateRouteOpacityLabel(opacityValue);
      }
      panel.style.display = 'block';
    }

function closeRouteEditor() {
  const panel = document.getElementById('route-editor');
  if (panel) panel.style.display = 'none';
}

function showRoutePopup(pinId, tr, latlng) {
  if (!tr || !tr.layer) return;
  const content = `<b>${tr.nazwa}</b><br>${tr.opis || ''}<br><button id="delRouteBtn">Usu≈Ñ trasƒô</button>`;
  const popup = L.popup()
    .setLatLng(latlng || tr.layer.getBounds().getCenter())
    .setContent(content)
    .openOn(map);
  const btn = popup.getElement().querySelector('#delRouteBtn');
  if (btn) {
    btn.addEventListener('click', () => {
      const pin = wszystkiePinezki.find(p => p.id === pinId);
      if (!pin) return;
      const idx = pin.trasy.indexOf(tr);
      if (idx > -1) {
        pin.trasy.splice(idx,1);
        if (tr.layer) rysowaneTrasy.removeLayer(tr.layer);
        zmianyDoZapisania[pin.id] = Object.assign(zmianyDoZapisania[pin.id] || {}, {trasy: pin.trasy.map(t => serializeRoute(t))});
        window.localTrasy.push({action:'delete', pinId: pin.id});
        generujListeWarstw();
        updateSaveButton();
        map.closePopup();
      }
    });
  }
}

    function applyRouteEdits() {
      if (!editedRoute) return;
      const pin = wszystkiePinezki.find(p => p.id === editedRoute.pinId);
      if (!pin || !pin.trasy || !pin.trasy[editedRoute.idx]) return;
      const name = document.getElementById('routeEditName').value.trim() || pin.trasy[editedRoute.idx].nazwa;
      const desc = document.getElementById('routeEditDesc').value.trim();
      const color = document.getElementById('routeEditColor').value || DEFAULT_ROUTE_COLOR;
      const opacityInput = document.getElementById('routeEditOpacity');
      const opacityPercent = opacityInput ? parseFloat(opacityInput.value) : 100;
      const opacity = normalizeRouteOpacity(Number.isNaN(opacityPercent) ? DEFAULT_ROUTE_OPACITY : opacityPercent / 100);
      pin.trasy[editedRoute.idx].nazwa = name;
      pin.trasy[editedRoute.idx].opis = desc;
      pin.trasy[editedRoute.idx].kolor = color;
      pin.trasy[editedRoute.idx].przezroczystosc = opacity;
      if (pin.trasy[editedRoute.idx].layer) {
        pin.trasy[editedRoute.idx].layer.setStyle({color, opacity});
      }
      pin.trasy[editedRoute.idx].unsaved = true;
      zmianyDoZapisania[pin.id] = Object.assign(zmianyDoZapisania[pin.id] || {}, {trasy: pin.trasy.map(t => serializeRoute(t))});
      window.localTrasy.push({action:'update', pinId: pin.id});
      generujListeWarstw();
      updateSaveButton();
      closeRouteEditor();
    }

    const routeOpacityInputEl = document.getElementById('routeEditOpacity');
    if (routeOpacityInputEl) {
      routeOpacityInputEl.addEventListener('input', () => updateRouteOpacityLabel(parseFloat(routeOpacityInputEl.value)));
    }

    document.getElementById('routeEditDelete').addEventListener('click', function(){
      if (!editedRoute) return;
      const pin = wszystkiePinezki.find(p => p.id === editedRoute.pinId);
      if (!pin || !pin.trasy || !pin.trasy[editedRoute.idx]) return;
      const tr = pin.trasy.splice(editedRoute.idx,1)[0];
      if (tr && tr.layer) rysowaneTrasy.removeLayer(tr.layer);
      zmianyDoZapisania[pin.id] = Object.assign(zmianyDoZapisania[pin.id] || {}, {trasy: pin.trasy.map(t => serializeRoute(t))});
      window.localTrasy.push({action:'delete', pinId: pin.id});
      generujListeWarstw();
      updateSaveButton();
      closeRouteEditor();
    });

    function showSearchMarker(lat, lng, label) {
      if (followGps) {
        followGps = false;
        const btn = document.getElementById('gpsFollowBtn');
        if (btn) btn.style.display = 'block';
      }
      const latNum = typeof lat === 'string' ? parseFloat(lat) : lat;
      const lngNum = typeof lng === 'string' ? parseFloat(lng) : lng;
      if (searchLayer) {
        map.removeLayer(searchLayer.layer);
        delete warstwy['wyszukane'];
        searchLayer = null;
        searchMarker = null;
      }
      searchLayer = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', temporary: true };
      warstwy['wyszukane'] = searchLayer;
      const latlng = L.latLng(latNum, lngNum);
      searchMarker = L.marker(latlng, {icon: greenIcon}).addTo(searchLayer.layer);
      const coordsDisplay = formatCoords(latNum, lngNum);
      const container = document.createElement('div');
      container.innerHTML = `
        <div>${label}</div>
        <div>${coordsDisplay}</div>
        <div class="popup-route-actions">
          <button class="popup-direct-route-btn" id="routeSearchBtn">Wyznacz trasƒô do</button>
          <button class="popup-route-btn" id="addSearchPin">dodaj pinezkƒô</button>
        </div>`;
      searchMarker.bindPopup(container).openPopup();
      container.querySelector('#addSearchPin').addEventListener('click', () => {
        if (searchLayer) {
          map.removeLayer(searchLayer.layer);
          delete warstwy['wyszukane'];
          searchLayer = null;
          searchMarker = null;
          generujListeWarstw();
        }
        openNewPinPopup(latlng);
      });
      const routeBtn = container.querySelector('#routeSearchBtn');
      if (routeBtn) {
        routeBtn.addEventListener('click', () => {
          map.closePopup();
          routeToPin({ lat: latNum, lng: lngNum }, routeBtn);
        });
      }
      searchLayer.lista.push({ id: 'search', nazwa: label, marker: searchMarker, lat: latNum, lng: lngNum });
      generujListeWarstw();
    }

    function initGeoSearch() {
      const input = document.getElementById('geosearch');
      const btn = document.getElementById('geosearchBtn');
      const suggestions = document.getElementById('geosearch-suggestions');
      if (!input) return;

      function executeSearch(q) {
        const coords = parseCoordinateInput(q);
        if (coords) {
          const [lat, lng] = coords;
          map.setView([lat, lng], 16);
          showSearchMarker(lat, lng, q);
          return;
        }

        const plusCodeMatch = q.match(/[A-Z0-9]{4,}\+[A-Z0-9]{2,}/i);
        if (plusCodeMatch) {
          fetch(`https://plus.codes/api?address=${encodeURIComponent(q)}`)
            .then(r => r.json())
            .then(data => {
              const location = data && data.geometry && data.geometry.location;
              if (location && Number.isFinite(location.lat) && Number.isFinite(location.lng)) {
                const label = (data.plus_code && (data.plus_code.compound_code || data.plus_code.global_code)) || q;
                map.setView([location.lat, location.lng], 16);
                showSearchMarker(location.lat, location.lng, label);
                return true;
              }
              return false;
            })
            .then(found => {
              if (!found) {
                return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
              }
              return null;
            })
            .then(resp => {
              if (!resp) return null;
              return resp.json();
            })
            .then(data => {
              if (!data) return;
              if (data && data[0]) {
                const lat = parseFloat(data[0].lat);
                const lng = parseFloat(data[0].lon);
                map.setView([lat, lng], 16);
                showSearchMarker(lat, lng, data[0].display_name);
              } else {
                alert('Nie znaleziono adresu');
              }
            })
            .catch(err => {
              console.error('Geocoding error', err);
              alert('B≈ÇƒÖd geokodowania');
            });
          return;
        }

        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`)
          .then(r => r.json())
          .then(data => {
            if (data && data[0]) {
              const lat = parseFloat(data[0].lat);
              const lng = parseFloat(data[0].lon);
              map.setView([lat, lng], 16);
              showSearchMarker(lat, lng, data[0].display_name);
            } else {
              alert('Nie znaleziono adresu');
            }
          })
          .catch(err => {
            console.error('Geocoding error', err);
            alert('B≈ÇƒÖd geokodowania');
          });
      }

      function handleSearch() {
        const q = input.value.trim();
        if (!q) return;
        executeSearch(q);
        if (suggestions) suggestions.style.display = 'none';
      }

      if (btn) btn.addEventListener('click', handleSearch);
      input.addEventListener('keydown', e => { if (e.key === 'Enter') handleSearch(); });

      input.addEventListener('focus', () => {
        if (input.value) {
          setTimeout(() => input.select(), 0);
        }
      });
      input.addEventListener('mouseup', e => {
        if (input.value) {
          e.preventDefault();
        }
      });

      let debounce;
      input.addEventListener('input', () => {
        const q = input.value.trim();
        if (debounce) clearTimeout(debounce);
        if (!suggestions) return;
        if (!q) { suggestions.style.display = 'none'; return; }
        debounce = setTimeout(() => {
          fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=5&q=${encodeURIComponent(q)}`)
            .then(r => r.json())
            .then(data => {
              suggestions.innerHTML = '';
              data.forEach(item => {
                const div = document.createElement('div');
                div.textContent = item.display_name;
                div.addEventListener('click', () => {
                  input.value = item.display_name;
                  suggestions.style.display = 'none';
                  map.setView([item.lat, item.lon], 16);
                  showSearchMarker(item.lat, item.lon, item.display_name);
                });
                suggestions.appendChild(div);
              });
              suggestions.style.display = data.length ? 'block' : 'none';
            });
        }, 300);
      });

      document.addEventListener('click', e => {
        if (!suggestions) return;
        if (!suggestions.contains(e.target) && e.target !== input) {
          suggestions.style.display = 'none';
        }
      });
    }

    function parseCoordinateInput(value) {
      if (!value) return null;
      const simpleMatch = value.match(/^\s*(-?\d+(?:[.,]\d+)?)\s*[,;\s]+\s*(-?\d+(?:[.,]\d+)?)\s*$/);
      if (simpleMatch && !/[NSEW]/i.test(value) && !/¬∞/.test(value)) {
        const lat = parseFloat(simpleMatch[1].replace(',', '.'));
        const lon = parseFloat(simpleMatch[2].replace(',', '.'));
        if (Number.isNaN(lat) || Number.isNaN(lon)) return null;
        return [lat, lon];
      }

      const hasDirectionalHints = /[NSEW]/i.test(value) || /¬∞/.test(value);
      if (!hasDirectionalHints) return null;

      const parseDirectionalPart = (part) => {
        if (!part) return null;
        let cleaned = part.trim().replace(/[¬∞]/g, '').replace(/\.+$/g, '');
        let dir = null;
        const leadingDir = cleaned.match(/^[NSEW]\b/i);
        if (leadingDir) {
          dir = leadingDir[0];
          cleaned = cleaned.replace(/^[NSEW]\b/i, '').trim();
        }
        const trailingDir = cleaned.match(/\b[NSEW]\b/i);
        if (trailingDir) {
          dir = dir || trailingDir[0];
          cleaned = cleaned.replace(/\b[NSEW]\b/i, '').trim();
        }
        const numberMatch = cleaned.match(/-?\d+(?:[.,]\d+)?/);
        if (!numberMatch) return null;
        let num = parseFloat(numberMatch[0].replace(',', '.'));
        if (Number.isNaN(num)) return null;
        if (dir) {
          if (/[SW]/i.test(dir)) {
            num = -Math.abs(num);
          } else {
            num = Math.abs(num);
          }
        }
        return num;
      };

      const parts = value.split(/[,;]/).map(part => part.trim()).filter(Boolean);
      let lat = null;
      let lon = null;
      if (parts.length >= 2) {
        lat = parseDirectionalPart(parts[0]);
        lon = parseDirectionalPart(parts[1]);
      } else {
        const tokens = value.match(/[NSEW]?\s*-?\d+(?:[.,]\d+)?\s*¬∞?\s*[NSEW]?/ig);
        if (tokens && tokens.length >= 2) {
          lat = parseDirectionalPart(tokens[0]);
          lon = parseDirectionalPart(tokens[1]);
        }
      }

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      return [lat, lon];
    }

    function formatRouteDuration(seconds) {
      if (!Number.isFinite(seconds)) return null;
      const minutes = Math.round(seconds / 60);
      if (minutes <= 0) {
        return '<1 min';
      }
      return `${minutes} min`;
    }

    async function fetchOsrmRoute(profile, sLat, sLon, eLat, eLon) {
      const url = `https://router.project-osrm.org/route/v1/${profile}/${sLon},${sLat};${eLon},${eLat}?overview=full&geometries=geojson`;
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`OSRM ${profile} request failed`);
      }
      const json = await response.json();
      if (!json.routes || !json.routes[0]) {
        throw new Error('Brak trasy');
      }
      return json.routes[0];
    }

    async function resolveAddressToCoords(value) {
      const coords = parseCoordinateInput(value);
      if (coords) return coords;
      return geocodeAddress(value);
    }

    function initRouteSearch() {
      const btn = document.getElementById('routeCalculate');
      const useCurrent = document.getElementById('routeUseCurrent');
      const clearBtn = document.getElementById('routeClear');
      const startInput = document.getElementById('routeStart');
      const endInput = document.getElementById('routeEnd');

      function updateRouteClearButton() {
        if (!clearBtn) return;
        const hasRoute = routingLayer && routingLayer.getLayers().length > 0;
        clearBtn.disabled = !hasRoute;
      }

      async function handleRouteSubmission() {
        const start = startInput?.value.trim();
        const end = endInput?.value.trim();

        if (!start) {
          alert('wprowad≈∫ punkt poczƒÖtkowy trasy');
          startInput?.focus();
          return;
        }

        if (!end) {
          alert('wprowad≈∫ punkt ko≈Ñcowy trasy');
          endInput?.focus();
          return;
        }

        const mode = document.querySelector('input[name="routeMode"]:checked')?.value || 'driving';
        await showRoute(start, end, mode);
        updateRouteClearButton();
      }

      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          if (routingLayer) {
            routingLayer.clearLayers();
          }
          if (startInput) startInput.value = '';
          if (endInput) endInput.value = '';
          updateRouteClearButton();
        });
      }
      if (useCurrent) {
        useCurrent.addEventListener('click', () => {
          if (!navigator.geolocation) {
            alert('Twoja przeglƒÖdarka nie wspiera geolokalizacji');
            return;
          }
          useCurrent.disabled = true;
          useCurrent.textContent = '‚Ä¶';
          navigator.geolocation.getCurrentPosition(pos => {
            const { latitude, longitude } = pos.coords;
            if (startInput) {
              startInput.value = `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
            }
            useCurrent.textContent = 'üìç';
            useCurrent.disabled = false;
          }, () => {
            alert('Nie uda≈Ço siƒô pobraƒá lokalizacji');
            useCurrent.textContent = 'üìç';
            useCurrent.disabled = false;
          });
        });
      }
      updateRouteClearButton();
      if (!btn) return;
      btn.addEventListener('click', handleRouteSubmission);
      [startInput, endInput].forEach(input => {
        if (!input) return;
        input.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleRouteSubmission();
          }
        });
      });
    }

    async function geocodeAddress(addr) {
      const coords = parseCoordinateInput(addr);
      if (coords) return coords;
      const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(addr)}`);
      const data = await resp.json();
      if (!data || !data[0]) throw new Error('Nie znaleziono adresu');
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }

    async function showRoute(startAddr, endAddr, mode = 'driving') {
      try {
        const [sLat, sLon] = await resolveAddressToCoords(startAddr);
        const [eLat, eLon] = await resolveAddressToCoords(endAddr);

        const routes = {};
        const profiles = ['driving', 'walking'];
        for (const profile of profiles) {
          try {
            routes[profile] = await fetchOsrmRoute(profile, sLat, sLon, eLat, eLon);
          } catch (profileErr) {
            console.warn(`Route calculation failed for ${profile}`, profileErr);
          }
        }

        const activeRoute = routes[mode] || routes.driving || routes.walking;
        if (!activeRoute) {
          throw new Error('Brak trasy');
        }

        routingLayer.clearLayers();
        const coords = activeRoute.geometry.coordinates.map(c => [c[1], c[0]]);
        const line = L.polyline(coords, {color: '#ff0000', weight: 4, className: 'route-line'}).addTo(routingLayer);
        map.fitBounds(line.getBounds());

        const drivingDuration = routes.driving?.duration;
        const walkingDuration = routes.walking?.duration;
        const tooltipParts = [];
        if (drivingDuration !== undefined) {
          const formatted = formatRouteDuration(drivingDuration);
          if (formatted) tooltipParts.push(`üöó ${formatted}`);
        }
        if (walkingDuration !== undefined) {
          const formatted = formatRouteDuration(walkingDuration);
          if (formatted) tooltipParts.push(`üö∂‚Äç‚ôÇÔ∏è ${formatted}`);
        }
        if (tooltipParts.length > 0) {
          line.bindTooltip(tooltipParts.join('<br>'), {
            permanent: true,
            direction: 'center',
            className: 'route-time-tooltip'
          }).openTooltip();
        }

        const clearBtn = document.getElementById('routeClear');
        if (clearBtn) clearBtn.disabled = false;
        return true;
      } catch (err) {
        console.error('Route error', err);
        alert('Nie uda≈Ço siƒô wyznaczyƒá trasy');
        const clearBtn = document.getElementById('routeClear');
        if (clearBtn && routingLayer && routingLayer.getLayers().length === 0) {
          clearBtn.disabled = true;
        }
        return false;
      }
    }

    function getCurrentPositionAsync(options = {}) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolokalizacja niedostƒôpna'));
          return;
        }
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });
    }

    async function routeToPin(pin, button) {
      if (!pin) return;
      const originalText = button?.textContent;
      try {
        if (button) {
          button.disabled = true;
          button.textContent = '‚Ä¶';
        }
        const position = await getCurrentPositionAsync({ enableHighAccuracy: true, timeout: 15000 });
        const { latitude, longitude } = position.coords;
        const startValue = `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
        const endValue = `${pin.lat.toFixed(6)}, ${pin.lng.toFixed(6)}`;

        const startInput = document.getElementById('routeStart');
        const endInput = document.getElementById('routeEnd');
        if (startInput) startInput.value = startValue;
        if (endInput) endInput.value = endValue;

        const mode = document.querySelector('input[name="routeMode"]:checked')?.value || 'driving';
        const success = await showRoute(startValue, endValue, mode);
        if (!success) {
          return;
        }
      } catch (err) {
        console.error('Route to pin error', err);
        if (err.code === 1) {
          alert('Brak zgody na dostƒôp do lokalizacji.');
        } else if (err.code === 2) {
          alert('Nie uda≈Ço siƒô ustaliƒá Twojej lokalizacji.');
        } else if (err.code === 3) {
          alert('Przekroczono czas oczekiwania na lokalizacjƒô.');
        } else if (err.message === 'Geolokalizacja niedostƒôpna') {
          alert('Twoja przeglƒÖdarka nie wspiera geolokalizacji.');
        } else {
          alert('Nie uda≈Ço siƒô wyznaczyƒá trasy do tej pinezki.');
        }
      } finally {
        if (button) {
          button.textContent = originalText || 'Wyznacz trasƒô do';
          button.disabled = false;
        }
      }
    }

    function updateStatusFilter() {
      const container = document.getElementById('status-lista');
      if (!container) return;
      container.innerHTML = '';
      const keys = statusOptions.map(s => s.key);
      const allDiv = document.createElement('div');
      const allChk = document.createElement('input');
      allChk.type = 'checkbox';
      allChk.id = 'status-all';
      allChk.checked = selectedStatuses.size === 0 || selectedStatuses.size === keys.length;
      const allLbl = document.createElement('label');
      allLbl.textContent = 'Zaznacz wszystkie';
      allDiv.appendChild(allChk);
      allDiv.appendChild(allLbl);
      container.appendChild(allDiv);
      allChk.addEventListener('change', () => {
        if (allChk.checked) {
          selectedStatuses = new Set(keys);
          container.querySelectorAll('.status-item input').forEach(ch => ch.checked = true);
        } else {
          selectedStatuses.clear();
          container.querySelectorAll('.status-item input').forEach(ch => ch.checked = false);
        }
        generujListeWarstw();
      });
      statusOptions.forEach(s => {
        const div = document.createElement('div');
        div.className = 'status-item';
        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.value = s.key;
        chk.checked = selectedStatuses.size === 0 || selectedStatuses.has(s.key);
        const lbl = document.createElement('label');
        lbl.innerHTML = s.label;
        div.appendChild(chk);
        div.appendChild(lbl);
        container.appendChild(div);
        chk.addEventListener('change', () => {
          selectedStatuses = new Set(Array.from(container.querySelectorAll('.status-item input')).filter(c => c.checked).map(c => c.value));
          const all = document.getElementById('status-all');
          if (all) all.checked = selectedStatuses.size === 0 || selectedStatuses.size === keys.length;
          generujListeWarstw();
        });
      });
    }

    function pinMatchesStatus(p) {
      if (selectedStatuses.size === 0 || selectedStatuses.size === statusOptions.length) return true;
      return statusOptions.some(s => selectedStatuses.has(s.key) && s.matches(p));
    }

    function updateCategoryFilter() {
      const container = document.getElementById('kategorie-lista');
      if (!container) return;
      container.innerHTML = '';
      const cats = Array.from(categories).sort();
      if (selectedCategories.size === 0) {
        selectedCategories = new Set(cats);
      }
      const allDiv = document.createElement('div');
      const allChk = document.createElement('input');
      allChk.type = 'checkbox';
      allChk.id = 'kategorie-all';
      allChk.checked = selectedCategories.size === 0 || selectedCategories.size === categories.size;
      const allLbl = document.createElement('label');
      allLbl.textContent = 'Zaznacz wszystkie';
      allDiv.appendChild(allChk);
      allDiv.appendChild(allLbl);
      container.appendChild(allDiv);
      allChk.addEventListener('change', () => {
        if (allChk.checked) {
          selectedCategories = new Set(categories);
          container.querySelectorAll('.kat-item input').forEach(ch => ch.checked = true);
        } else {
          selectedCategories.clear();
          container.querySelectorAll('.kat-item input').forEach(ch => ch.checked = false);
        }
        generujListeWarstw();
      });
      cats.forEach(cat => {
        const div = document.createElement('div');
        div.className = 'kat-item';
        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.value = cat;
        chk.checked = selectedCategories.size === 0 || selectedCategories.has(cat);
        const lbl = document.createElement('label');
        lbl.textContent = cat || 'Bez kategorii';
        div.appendChild(chk);
        div.appendChild(lbl);
        container.appendChild(div);
        chk.addEventListener('change', () => {
          selectedCategories = new Set(
            Array.from(container.querySelectorAll('.kat-item input')).filter(c => c.checked).map(c => c.value)
          );
          const all = document.getElementById('kategorie-all');
          if (all) all.checked = selectedCategories.size === categories.size;
          generujListeWarstw();
        });
      });
    }

    function updateMarkerVisibility() {
      Object.values(warstwy).forEach(w => {
        w.lista.forEach(p => {
          if (!p.marker) return;
          const visible = (selectedCategories.size === 0 || selectedCategories.has(p.kategoria || '')) && pinMatchesStatus(p);
          if (visible) {
            if (!w.layer.hasLayer(p.marker)) {
              w.layer.addLayer(p.marker);
            }
          } else {
            if (w.layer.hasLayer(p.marker)) {
              w.layer.removeLayer(p.marker);
            }
          }
          updatePlanVisibilityForPin(p);
        });
      });
    }

    function generujListeWarstw() {
      updateMarkerVisibility();
      layerDomRefs = {};
      const lista = document.getElementById("lista-warstw");
      lista.innerHTML = "";
      const saved = loadLayerOrder();
      const collapseStates = shouldIgnoreStoredLayerState ? {} : loadLayerCollapseStates();
      const visibilityStates = shouldIgnoreStoredLayerState ? {} : loadLayerVisibilityStates();
      const nazwy = [...saved.filter(n => warstwy[n]), ...Object.keys(warstwy).filter(n => !saved.includes(n))];
      const tempLayers = nazwy.filter(n => warstwy[n].temporary);
      const regularLayers = nazwy.filter(n => !warstwy[n].temporary);
      const finalNazwy = [...tempLayers, ...regularLayers];
      finalNazwy.forEach((nazwa, idx) => {
        const div = document.createElement("div");
        div.className = "warstwa";
        div.dataset.nazwa = nazwa;
        const numberSpan = document.createElement("span");
        numberSpan.className = "layer-number";
        numberSpan.textContent = idx + 1;
        if (!warstwy[nazwa].temporary) {
          setupDrag(div, numberSpan);
        }
        const h3 = document.createElement("h3");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        const hasStoredVisibility = !warstwy[nazwa].temporary && visibilityStates.hasOwnProperty(nazwa);
        if (hasStoredVisibility) {
          warstwy[nazwa].visible = !!visibilityStates[nazwa];
          if (warstwy[nazwa].visible) {
            if (!map.hasLayer(warstwy[nazwa].layer)) {
              warstwy[nazwa].layer.addTo(map);
            }
          } else {
            map.removeLayer(warstwy[nazwa].layer);
          }
        } else if (shouldApplyDefaultLayerState && !warstwy[nazwa].temporary) {
          applyLayerDefaultState(nazwa);
        }
        if (warstwy[nazwa].visible === undefined) {
          warstwy[nazwa].visible = map.hasLayer(warstwy[nazwa].layer);
        }
        if (!hasStoredVisibility && window.innerWidth <= 700 && !initialLayerVisibilitySet && !shouldApplyDefaultLayerState) {
          warstwy[nazwa].visible = false;
          map.removeLayer(warstwy[nazwa].layer);
        }
        checkbox.checked = warstwy[nazwa].visible;
        checkbox.onchange = () => {
          warstwy[nazwa].visible = checkbox.checked;
          if (checkbox.checked) {
            warstwy[nazwa].layer.addTo(map);
          } else {
            map.removeLayer(warstwy[nazwa].layer);
          }
          if (!warstwy[nazwa].temporary) {
            setLayerVisibilityState(nazwa, checkbox.checked);
          }
          allLayersVisible = Object.values(warstwy).every(w => w.visible);
          if (toggleVisibilityBtn) {
            toggleVisibilityBtn.textContent = allLayersVisible ? 'Ukryj wszystkie warstwy' : 'Poka≈º wszystkie warstwy';
          }
        };
        const label = document.createElement("span");
        label.textContent = `${nazwa} (${warstwy[nazwa].lista.length})`;
        const left = document.createElement("span");
        left.appendChild(checkbox);
        left.appendChild(numberSpan);
        left.appendChild(label);
        if (collapseStates.hasOwnProperty(nazwa)) {
          warstwy[nazwa].collapsed = collapseStates[nazwa];
        } else if (!warstwy[nazwa].temporary) {
          if (shouldIgnoreStoredLayerState) {
            warstwy[nazwa].collapsed = true;
          } else if (shouldApplyDefaultLayerState) {
            warstwy[nazwa].collapsed = !getLayerDefaultVisible(nazwa);
          }
        }
        const toggleBtn = document.createElement("span");
        toggleBtn.textContent = warstwy[nazwa].collapsed ? "‚ñ∂Ô∏è" : "üîΩ";
       toggleBtn.style.cursor = "pointer";
toggleBtn.style.display = "inline-block";
toggleBtn.style.verticalAlign = "top";
        const controls = document.createElement("span");
        if (!warstwy[nazwa].temporary) {
          const editBtn = document.createElement("span");
          editBtn.textContent = "‚úèÔ∏è";
          editBtn.style.cursor = "pointer";
          editBtn.style.marginRight = "5px";
          editBtn.style.display = "inline-block";
          editBtn.style.verticalAlign = "top";
          editBtn.onclick = () => showLayerEditor(nazwa);
          controls.appendChild(editBtn);
        }
        controls.appendChild(toggleBtn);
        controls.style.display = "flex";
        controls.style.alignItems = "center";
        h3.appendChild(left);
        h3.appendChild(controls);
        div.appendChild(h3);

        const listaP = document.createElement("div");
        listaP.className = "pinezki-lista";

        const sorted = warstwy[nazwa].lista.slice().filter(p => {
          return (selectedCategories.size === 0 || selectedCategories.has(p.kategoria || '')) && pinMatchesStatus(p);
        }).sort((a, b) => {
          const ad = a.dataDodania ? new Date(a.dataDodania).getTime() : 0;
          const bd = b.dataDodania ? new Date(b.dataDodania).getTime() : 0;
          const an = a.nazwa || '';
          const bn = b.nazwa || '';
          switch (sortMode) {
            case 'dateAsc':
              return ad - bd;
            case 'dateDesc':
              return bd - ad;
            case 'nameDesc':
              return bn.localeCompare(an);
            case 'nameAsc':
            default:
              return an.localeCompare(bn);
          }
        });
        sorted.forEach(p => {
          const el = document.createElement("div");
          el.className = "pinezka";
          el.dataset.pinId = String(p.id);
          const dispEmoji = warstwy[nazwa].emoji || p.emoji;
          el.innerHTML = (dispEmoji ? emojiHtml(dispEmoji) + ' ' : '') + p.nazwa;
          if (p.unsaved) el.classList.add('unsaved');
          if (selectedPinIds.has(String(p.id))) {
            el.classList.add('selected');
          }
          el.addEventListener('click', e => {
            const selectionHandled = handlePinSelectionClick(e, p, el);
            if (selectionHandled) return;
            if (isMobile && followGps) {
              followGps = false;
              const gpsBtn = document.getElementById('gpsFollowBtn');
              if (gpsBtn) gpsBtn.style.display = 'block';
            }
            map.setView([p.lat, p.lng], 16);
            p.marker.openPopup();
            highlightListItem(el);
          });
          if (p.marker) {
            attachHighlight(p.marker, el);
          }
          p.el = el;
          applyInactiveStyle(p);
          listaP.appendChild(el);

          const trList = document.createElement('div');
          trList.className = 'trasy-lista';
          (p.trasy || []).forEach((tr, ti) => {
            const tEl = document.createElement('div');
            tEl.className = 'trasa-item';
            tEl.textContent = tr.nazwa;
            tEl.title = tr.opis || '';
            tEl.style.borderLeft = `4px solid ${tr.kolor || DEFAULT_ROUTE_COLOR}`;
            if (tr.unsaved) tEl.classList.add('unsaved');
            tEl.onclick = (e) => {
              e.stopPropagation();
              if (tr.layer) map.fitBounds(tr.layer.getBounds());
            };
            const editR = document.createElement('span');
            editR.textContent = '‚úèÔ∏è';
            editR.style.marginLeft = '5px';
            editR.onclick = (e) => { e.stopPropagation(); showRouteEditor(p.id, ti); };
            tEl.appendChild(editR);
            trList.appendChild(tEl);
          });
          el.appendChild(trList);

          if ((p.plany || []).length) {
            const plansWrapper = document.createElement('div');
            plansWrapper.className = 'trasy-lista';
            const plansHeader = document.createElement('div');
            plansHeader.style.fontSize = '12px';
            plansHeader.style.margin = '4px 0';
            plansHeader.textContent = 'Plany:';
            plansWrapper.appendChild(plansHeader);
            (p.plany || []).forEach(pl => {
              const row = document.createElement('div');
              row.className = 'plan-item';
              if (pl.unsaved) row.classList.add('unsaved');
              const chk = document.createElement('input');
              chk.type = 'checkbox';
              chk.className = 'plan-visibility';
              chk.checked = pl.widoczny !== false;
              chk.addEventListener('click', ev => ev.stopPropagation());
              chk.addEventListener('change', () => {
                pl.widoczny = chk.checked;
                pl.unsaved = true;
                updatePlanOverlay(p, pl);
                markPlanChange(p);
              });
              const nameSpan = document.createElement('span');
              nameSpan.className = 'plan-name';
              nameSpan.textContent = pl.nazwa || 'Plan';
              nameSpan.addEventListener('click', ev => {
                ev.stopPropagation();
                openPlanOptions(p, pl, nameSpan);
              });
              row.appendChild(chk);
              row.appendChild(nameSpan);
              plansWrapper.appendChild(row);
            });
            el.appendChild(plansWrapper);
          }
        });

        layerDomRefs[nazwa] = {
          name: nazwa,
          label,
          totalCount: warstwy[nazwa].lista.length,
          items: Array.from(listaP.querySelectorAll('.pinezka'))
        };

        if (warstwy[nazwa].collapsed) listaP.classList.add("ukryta");
        toggleBtn.onclick = () => {
          warstwy[nazwa].collapsed = !warstwy[nazwa].collapsed;
          listaP.classList.toggle("ukryta");
          toggleBtn.textContent = listaP.classList.contains("ukryta") ? "‚ñ∂Ô∏è" : "üîΩ";
          setLayerCollapseState(nazwa, warstwy[nazwa].collapsed);
        };

        div.appendChild(listaP);
        lista.appendChild(div);
        const sep = document.createElement('hr');
        sep.className = 'layer-separator';
        lista.appendChild(sep);
      });
      saveLayerOrder({ markChange: false });
      updateLayerNumbers();
      updateSelectionStyles();
      updateBulkPanel();

      if (window.innerWidth <= 700) {
        initialLayerVisibilitySet = true;
      }

      applySearchFilter();
      allLayersVisible = Object.values(warstwy).every(w => w.visible);
      if (toggleVisibilityBtn) {
        toggleVisibilityBtn.textContent = allLayersVisible ? 'Ukryj wszystkie warstwy' : 'Poka≈º wszystkie warstwy';
      }
      persistAllLayerVisibilityStates();
      shouldIgnoreStoredLayerState = false;
    }

    async function zapiszZmiany() {
      const btn = document.getElementById('saveChanges'); // [CODEx CHANGED] fragment w zapiszZmiany()
      const origLabel = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Zapisywanie‚Ä¶';
      try {
        let totalAll = 0;
        Object.entries(zmianyDoZapisania).forEach(([id]) => {
          const p = wszystkiePinezki.find(pp => pp.id === id);
          if (!p || !p.firebaseId) return;
          const lp = getStoredPhotos(p.slug) || [];
          lp.forEach(ph => { if (!ph.path) totalAll++; });
          (p.plany || []).forEach(pl => { if (!pl.path) totalAll++; });
        });
        nowePinezki.forEach(p => {
          const lp = getStoredPhotos(p.slug) || [];
          lp.forEach(ph => { if (!ph.path) totalAll++; });
          (p.plany || []).forEach(pl => { if (!pl.path) totalAll++; });
        });
        let doneAll = 0;
        const onProgress = () => {
          doneAll++;
          btn.textContent = `Zapisywanie‚Ä¶ (${doneAll}/${totalAll})`;
        };

        const updatePromises = Object.entries(zmianyDoZapisania).map(async ([id, data]) => {
          const p = wszystkiePinezki.find(pp => pp.id === id);
          if (!p || !p.firebaseId) return;
          const { plany: _pendingPlans, ...rest } = data || {};
          if (Object.keys(rest).length > 0) {
            if (rest.warstwa !== undefined || rest.warstwaId !== undefined) {
              const layerInfo = resolveLayerInfo(rest.warstwa, rest.warstwaId);
              if (layerInfo.warstwaId) {
                rest.warstwa = layerInfo.warstwaId;
                rest.warstwaId = layerInfo.warstwaId;
              } else {
                rest.warstwa = null;
                rest.warstwaId = null;
              }
            }
            await db.collection('pinezki2').doc(p.firebaseId).update(rest);
          }
          const localPhotos = getStoredPhotos(p.slug);
          p.photos = await savePhotosForPin(p.firebaseId, p.slug, localPhotos, p.photos || [], onProgress);
          p.plany = await savePlansForPin(p.firebaseId, p.slug, p.plany || [], p.savedPlans || [], onProgress);
          p.savedPlans = serializePlans(p);
          delete p.unsaved;
        });

        const addPromises = nowePinezki.map(async p => {
          const suffix = generateSuffix();
          const firebaseId = `${sanitize(p.nazwa)}_${suffix}`;
          p.firebaseId = firebaseId;
          const layerInfo = resolveLayerInfo(p.warstwa, p.warstwaId);
          const payload = {
            nazwa: p.nazwa,
            opis: p.opis,
            warstwa: layerInfo.warstwaId || null,
            warstwaId: layerInfo.warstwaId || null,
            kategoria: p.kategoria,
            emoji: p.emoji,
            nieaktywne: p.nieaktywne || false,
            zamkniete: p.zamkniete || false,
            tajne: p.tajne || false,
            doSprawdzenia: p.doSprawdzenia || false,
            zdewastowane: p.zdewastowane || false,
            zwiedzone: p.zwiedzone || false,
            wyroznione: p.wyroznione || false,
            lat: p.lat,
            lng: p.lng,
            dataDodania: firebase.firestore.FieldValue.serverTimestamp(),
            IDpinezki: p.id,
            odKogo: p.odKogo || '',
            trasy: (p.trasy || []).map(t => serializeRoute(t)),
            plany: []
          };
          if (p.trudnosc !== undefined) payload.trudnosc = p.trudnosc;
          await db.collection('pinezki2').doc(firebaseId).set(payload);
          const localPhotos = getStoredPhotos(p.slug);
          p.photos = await savePhotosForPin(firebaseId, p.slug, localPhotos, [], onProgress);
          p.plany = await savePlansForPin(firebaseId, p.slug, p.plany || [], [], onProgress);
          p.savedPlans = serializePlans(p);
        });

        const deletePinPromises = pinsToDelete.map(info => {
          const firebaseId = info && info.firebaseId;
          if (firebaseId) {
            return db.collection('pinezki2').doc(firebaseId).delete().catch(()=>{});
          }
          const p = wszystkiePinezki.find(pp => pp.id === (info ? info.id : info));
          if (p && p.firebaseId) return db.collection('pinezki2').doc(p.firebaseId).delete().catch(()=>{});
          return Promise.resolve();
        });

        const orderList = loadLayerOrder();
        const layerUpdates = Object.keys(warstwy).map(name => {
          const order = orderList.indexOf(name);
          const docId = layerDocs[name];
          const payload = {name, order, emoji: warstwy[name].emoji || '', defaultVisible: getLayerDefaultVisible(name)};
          if (docId) {
            return db.collection('layers').doc(docId).set(payload);
          } else if (layersToAdd.includes(name)) {
            return db.collection('layers').add(payload);
          }
          return Promise.resolve();
        });

        const layerDeletes = layersToDelete.map(name => {
          const id = layerDocs[name];
          if (id) return db.collection('layers').doc(id).delete().catch(()=>{});
          return Promise.resolve();
        });

        await Promise.all([...updatePromises, ...addPromises, ...deletePinPromises, ...layerUpdates, ...layerDeletes]);
        zmianyDoZapisania = {};
        nowePinezki = [];
        layersToAdd = [];
        layersToDelete = [];
        layerEmojiChanges = {};
        layerDefaultVisibilityChanges = {};
        pinsToDelete = [];
        window.localTrasy = [];
        localStorage.removeItem('nowePinezki');
        shouldWarnBeforeUnload = false;
        btn.textContent = 'Zapisano ‚úî';
        persistAllLayerCollapseStates();
        persistAllLayerVisibilityStates();
        localStorage.setItem(LAYER_STATE_PRESERVE_FLAG_KEY, '1');
        location.reload();
      } catch (err) {
        console.error(err);
        alert('Nie uda≈Ço siƒô zapisaƒá zmian. Spr√≥buj ponownie.');
        btn.textContent = origLabel;
      } finally {
        setTimeout(() => {
          btn.textContent = origLabel;
          btn.disabled = false;
        }, 600);
      }
    }

    document.getElementById('saveChanges').addEventListener('click', zapiszZmiany);

    function escapeXml(str) {
      return String(str || '').replace(/[<>&'"]/g, c => {
        switch (c) {
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '&': return '&amp;';
          case '"': return '&quot;';
          case "'": return '&apos;';
          default: return c;
        }
      });
    }

    function buildKml(pins) {
      const placemarks = pins.map(p => {
        const name = escapeXml(p.nazwa);
        const desc = escapeXml(p.opis);
        return `<Placemark><name>${name}</name><description>${desc}</description><Point><coordinates>${p.lng},${p.lat},0</coordinates></Point></Placemark>`;
      }).join('');
      return `<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2"><Document>${placemarks}</Document></kml>`;
    }

    async function exportPinsToKML() {
      try {
        const snapshot = await db.collection('pinezki2').get();
        const pins = [];
        snapshot.forEach(doc => pins.push(doc.data()));
        const kml = buildKml(pins);
        const blob = new Blob([kml], {type: 'application/vnd.google-earth.kml+xml'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pinezki.kml';
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 0);
      } catch (err) {
        alert('B≈ÇƒÖd eksportu: ' + err.message);
      }
    }

    document.getElementById('exportKML').addEventListener('click', exportPinsToKML);

  document.addEventListener("DOMContentLoaded", () => {
    if (window.twemoji && typeof window.twemoji.parse === 'function') {
      try {
        window.twemoji.parse(document.body, {
          folder: "svg",
          ext: ".svg"
        });
      } catch (err) {
        console.warn('twemoji.parse failed', err);
      }
    }
    const modal = document.getElementById('photoModal');
    if (modal) {
      modal.addEventListener('click', e => {
        if (e.target === modal || e.target.id === 'photoModalClose') {
          modal.style.display = 'none';
        }
      });
    }

    const delModal = document.getElementById('deleteModal');
    const deleteYesBtn = document.getElementById('deleteConfirmYes');
    const deleteNoBtn = document.getElementById('deleteConfirmNo');
    if (delModal && deleteYesBtn && deleteNoBtn) {
      deleteYesBtn.addEventListener('click', () => {
        const targetId = delModal.dataset.pinId;
        if (targetId) {
          deletePinLocal(targetId);
        } else {
          closeDeleteModal();
        }
      });
      deleteNoBtn.addEventListener('click', closeDeleteModal);
      delModal.addEventListener('click', e => {
        if (e.target === delModal) closeDeleteModal();
      });
    }

    const layerDelModal = document.getElementById("layerDeleteModal");
    if (layerDelModal) {
      document.getElementById("layerDeleteConfirmYes").addEventListener("click", confirmLayerDelete);
      document.getElementById("layerDeleteConfirmNo").addEventListener("click", closeLayerDeleteModal);
      layerDelModal.addEventListener("click", e => {
        if (e.target === layerDelModal) closeLayerDeleteModal();
      });
    }

    const planScaleInput = document.getElementById('planScale');
    if (planScaleInput) planScaleInput.addEventListener('input', e => planScaleChanged(e.target.value));
    const planOpacityInput = document.getElementById('planOpacity');
    if (planOpacityInput) planOpacityInput.addEventListener('input', e => planOpacityChanged(e.target.value));
    const planChangeImageBtn = document.getElementById('planChangeImage');
    if (planChangeImageBtn) planChangeImageBtn.addEventListener('click', () => changeActivePlanImage());
    const planCancelBtn = document.getElementById('planCancel');
    if (planCancelBtn) planCancelBtn.addEventListener('click', () => closePlanEditor(true));
    const planConfirmBtn = document.getElementById('planConfirm');
    if (planConfirmBtn) planConfirmBtn.addEventListener('click', confirmPlanPlacement);
    initLayerEditor();

    setupMobile();

  });

  let modalSlug = null;
  let modalIndex = null;
  function openPhotoModal(slug, idx) {
    modalSlug = slug;
    modalIndex = idx;
    const photos = getStoredPhotos(slug);
    const ph = photos[idx];
    if (!ph) return;
    const oldImg = document.getElementById('photoModalImg');
    if (oldImg) {
      const img = imgWithFallback(ph.url);
      img.id = 'photoModalImg';
      oldImg.replaceWith(img);
    }
    const delBtn = document.getElementById('photoModalDelete');
    if (delBtn) {
      const gallery = document.querySelector(`.photo-gallery[data-slug="${slug}"]`);
      delBtn.style.display = gallery && gallery.closest('.edit-popup') ? 'block' : 'none';
    }
    const modal = document.getElementById('photoModal');
    if (modal) modal.style.display = 'flex';
  }

  function deleteCurrentPhoto() {
    if (modalSlug === null) return;
    const photos = getStoredPhotos(modalSlug);
    const removed = photos.splice(modalIndex, 1)[0];
    storePhotos(modalSlug, photos);
    const gallery = document.querySelector(`.photo-gallery[data-slug="${modalSlug}"]`);
    if (gallery) renderGallery(gallery);
    markPinUnsaved(modalSlug);
    updateSaveButton();
    modalSlug = null; modalIndex = null;
    const modal = document.getElementById('photoModal');
    if (modal) modal.style.display = 'none';
  }

  async function savePlansForPin(id, slug, localPlans, remotePlans, onProgress) {
    const finalPlans = [];
    const remoteMap = {};
    (remotePlans || []).forEach(pl => { if (pl && pl.path) remoteMap[pl.path] = pl; });
    let totalNew = 0;
    for (const pl of (localPlans || [])) { if (pl && !pl.path) totalNew++; }
    let doneNew = 0;

    for (const pl of (localPlans || [])) {
      if (!pl) continue;
      if (pl.path) {
        finalPlans.push({ ...pl });
        delete remoteMap[pl.path];
        continue;
      }
      const compressed = await compressDataUrl(pl.url);
      const fileName = `${Date.now()}_${Math.random().toString(36).slice(2)}.jpg`;
      const path = `plans/${id}/${fileName}`;
      const ref = storage.ref().child(path);
      await ref.putString(compressed, 'data_url');
      const url = await ref.getDownloadURL();
      finalPlans.push({ ...pl, url, path });
      doneNew++;
      if (typeof onProgress === 'function') onProgress(doneNew, totalNew);
    }

    const toDelete = Object.keys(remoteMap);
    for (const path of toDelete) {
      try { await storage.ref().child(path).delete(); } catch (e) {}
    }

      await db.collection('pinezki2').doc(id).update({
        plany: finalPlans.map(pl => ({
          id: pl.id,
          nazwa: pl.nazwa,
          url: pl.url,
        path: pl.path || null,
        pozycja: pl.pozycja,
        szerokosc: pl.szerokosc,
        wysokosc: pl.wysokosc,
        proporcja: pl.proporcja,
          bazowaSzerokosc: pl.bazowaSzerokosc,
          skala: pl.skala,
          przezroczystosc: pl.przezroczystosc,
          obrot: pl.obrot || 0,
          widoczny: pl.widoczny !== false
        }))
      });

    return finalPlans;
  }

  // === [CODEx REPLACED] Upload i zapis listy zdjƒôƒá z kompresjƒÖ ===
  async function savePhotosForPin(id, slug, localPhotos, remotePhotos, onProgress) {
    // localPhotos: [{url, path?}]   (nowe zdjƒôcia majƒÖ tylko 'url' = dataURL)
    // remotePhotos: [{url, path}]   (to co ju≈º jest w Firestore/Storage)
    const finalPhotos = [];
    const remoteMap = {};
    (remotePhotos || []).forEach(ph => { if (ph.path) remoteMap[ph.path] = ph; });

    let totalNew = 0;
    for (const ph of (localPhotos || [])) if (!ph.path) totalNew++;

    let doneNew = 0;

    for (const ph of (localPhotos || [])) {
      if (ph.path) {
        // istniejƒÖce zdjƒôcie zostaje
        finalPhotos.push({ url: ph.url, path: ph.path });
        delete remoteMap[ph.path];
      } else if (ph.legacy) {
        // LEGACY: stare 'photo' ‚Äì NIE uploadujemy, NIE kompresujemy
        // WERSJA A (domy≈õlna): zachowaj w Firestore, ale tylko jako { url }
        finalPhotos.push({ url: ph.url });

        // --- WERSJA B (opcjonalnie: legacy tylko w runtime, nie zapisuj do Firestore) ---
        // Aby w≈ÇƒÖczyƒá WERSJƒò B, ZAMIENIƒÜ powy≈ºszƒÖ liniƒô na:
        // continue;

      } else {
        // NOWE zdjƒôcie (dataURL) -> kompresja + upload
        const compressedDataUrl = await compressDataUrl(ph.url);
        // (opcjonalny) pr√≥g po kompresji:
        // if (compressedDataUrl.length > 500 * 1024) console.warn('Du≈ºe foto po kompresji');

        const fileName = `${Date.now()}_${Math.random().toString(36).slice(2)}.jpg`;
        const path = `pins/${id}/${fileName}`;
        const ref = storage.ref().child(path);

        await ref.putString(compressedDataUrl, 'data_url');
        const url = await ref.getDownloadURL();

        finalPhotos.push({ url, path });

        doneNew++;
        if (typeof onProgress === 'function') onProgress(doneNew, totalNew);
      }
    }

    // Usu≈Ñ ze Storage zdjƒôcia skasowane w UI
    const toDelete = Object.keys(remoteMap);
    for (const path of toDelete) {
      try { await storage.ref().child(path).delete(); } catch (e) {}
    }

    // Zapis listy zdjƒôƒá w dokumencie pinezki
    await db.collection('pinezki2').doc(id).update({ photos: finalPhotos });

    // Synchronizacja lokalnego cache'a je≈õli istnieje
    if (typeof storePhotos === 'function') {
      storePhotos(slug, finalPhotos);
    }

    return finalPhotos;
  }

  function openDeleteModal(id) {
    const modal = document.getElementById('deleteModal');
    if (modal) {
      modal.dataset.pinId = id;
      const txt = modal.querySelector('#deleteModalContent div');
      const p = wszystkiePinezki.find(pp => pp.id === id);
      if (txt && p) txt.textContent = `Czy na pewno chcesz usunƒÖƒá pinezkƒô ${p.nazwa}?`;
      modal.style.display = 'flex';
    }
  }

  function closeDeleteModal() {
    const modal = document.getElementById('deleteModal');
    if (modal) {
      delete modal.dataset.pinId;
      modal.style.display = 'none';
    }
  }

  function deletePinLocal(id, record = true) {
    const p = wszystkiePinezki.find(pp => String(pp.id) === String(id));
    if (!p) {
      closeDeleteModal();
      return;
    }
    const layerName = p.warstwa || 'Inne';
    const backup = {
      pin: p,
      layerName,
      prevPinsToDelete: pinsToDelete.slice(),
      prevNowe: nowePinezki.slice(),
      prevZmiany: Object.assign({}, zmianyDoZapisania),
      prevAll: wszystkiePinezki.slice()
    };
    if (p.firebaseId) pinsToDelete.push({ id: p.id, firebaseId: p.firebaseId });
    const idxN = nowePinezki.indexOf(p);
    if (idxN > -1) nowePinezki.splice(idxN, 1);
    delete zmianyDoZapisania[p.id];
    if (p.marker) map.removeLayer(p.marker);
    if (p.plany) p.plany.forEach(pl => removePlanOverlay(pl));
    const layer = warstwy[layerName];
    if (layer) {
      const idx = layer.lista.indexOf(p);
      if (idx > -1) layer.lista.splice(idx, 1);
    }
    wszystkiePinezki = wszystkiePinezki.filter(pp => pp !== p);
    generujListeWarstw();
    updateSaveButton();
    if (record) {
      pushAction({
        undo: () => {
          wszystkiePinezki = backup.prevAll;
          if (backup.pin.marker) backup.pin.marker.addTo(warstwy[backup.layerName].layer);
          warstwy[backup.layerName].lista.push(backup.pin);
          if (backup.pin.plany) backup.pin.plany.forEach(pl => ensurePlanOverlay(backup.pin, pl));
          pinsToDelete = backup.prevPinsToDelete;
          nowePinezki = backup.prevNowe;
          zmianyDoZapisania = Object.assign({}, backup.prevZmiany);
          generujListeWarstw();
          updateSaveButton();
        },
        redo: () => { deletePinLocal(id, false); }
      }, 'Usuniƒôto pinezkƒô');
    }
    closeDeleteModal();
  }

let layerDeleteName = null;
function openLayerDeleteModal(name) {
  layerDeleteName = name;
  const modal = document.getElementById("layerDeleteModal");
  if (modal) {
    const txt = modal.querySelector('#layerDeleteModalContent div');
    if (txt) txt.textContent = `Czy na pewno chcesz usunƒÖƒá warstwƒô ${name} i wszystkie jej pinezki?`;
    modal.style.display = "flex";
  }
}
function closeLayerDeleteModal() {
  layerDeleteName = null;
  const modal = document.getElementById("layerDeleteModal");
  if (modal) modal.style.display = "none";
}
function confirmLayerDelete() {
  if (!layerDeleteName) return;
  deleteLayer(layerDeleteName);
  closeLayerDeleteModal();
}

  const isMobile = window.matchMedia('(max-width: 768px)').matches;

  const GPS_ARROW_BASE_TRANSFORM = 'translate(-50%, calc(-50% - 8px))';
  let currentLocation = null;
  let currentMarker = null;
  const gpsIcon = L.divIcon({
    className: 'gps-marker',
    html: '<div class="gps-arrow"></div><div class="gps-dot"></div>',
    iconSize: [24, 24],
    iconAnchor: [12, 12]
  });
  let followGps = true;

  function updateGpsHeading(heading) {
    if (!currentMarker) return;
    const markerEl = currentMarker.getElement();
    if (!markerEl) return;
    const arrow = markerEl.querySelector('.gps-arrow');
    if (!arrow) return;

    if (typeof heading === 'number' && !Number.isNaN(heading)) {
      const normalized = (heading + 360) % 360;
      arrow.style.transform = `${GPS_ARROW_BASE_TRANSFORM} rotate(${normalized}deg)`;
      markerEl.classList.add('has-heading');
    } else {
      arrow.style.transform = `${GPS_ARROW_BASE_TRANSFORM} rotate(0deg)`;
      markerEl.classList.remove('has-heading');
    }
  }

  function initGeolocation() {
    if (!navigator.geolocation) return;
    const gpsLoading = document.getElementById('gpsLoadingMessage');
    if (isMobile && gpsLoading) {
      gpsLoading.style.display = 'block';
    }
    navigator.geolocation.watchPosition(pos => {
      currentLocation = [pos.coords.latitude, pos.coords.longitude];
      const heading = pos.coords.heading;
      let markerCreated = false;
      if (!currentMarker) {
        currentMarker = L.marker(currentLocation, {icon: gpsIcon}).addTo(map);
        map.setView(currentLocation, 16);
        markerCreated = true;
      } else {
        currentMarker.setLatLng(currentLocation);
      }
      if (markerCreated) {
        requestAnimationFrame(() => updateGpsHeading(heading));
      } else {
        updateGpsHeading(heading);
      }
      if (followGps) {
        map.setView(currentLocation, map.getZoom());
      }
      if (isMobile && gpsLoading) {
        gpsLoading.style.display = 'none';
      }
    }, err => {
      console.error('geo error', err);
      if (isMobile && gpsLoading) {
        gpsLoading.style.display = 'none';
      }
    }, { enableHighAccuracy: true });
  }

  async function ensureMovingLayer() {
    if (movingLayerId) return;
    const snap = await db.collection('layers').where('name','==','Tryb w ruchu').get();
    if (!snap.empty) {
      movingLayerId = snap.docs[0].id;
    } else {
      const doc = await db.collection('layers').add({name:'Tryb w ruchu', order:Object.keys(warstwy).length});
      movingLayerId = doc.id;
    }
    const name = 'Tryb w ruchu';
    layerDocs[name] = movingLayerId;
    layerNamesById[movingLayerId] = name;
    if (!warstwy[name]) {
      warstwy[name] = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', defaultVisible: true };
    }
    generujListeWarstw();
  }

  async function saveMovingPin(name) {
    if (!currentLocation) {
      alert('Brak aktualnej lokalizacji');
      return;
    }
    await ensureMovingLayer();
    if (warstwy['Tryb w ruchu']) {
      warstwy['Tryb w ruchu'].visible = true;
      warstwy['Tryb w ruchu'].layer.addTo(map);
    }
    const suffix = generateSuffix();
    const firebaseId = `${sanitize(name)}_${suffix}`;
    const IDpinezki = crypto.randomUUID();
      await db.collection('pinezki2').doc(firebaseId).set({
        nazwa: name,
        opis: '',
        warstwa: movingLayerId,
        warstwaId: movingLayerId,
        kategoria: '',
        emoji: '',
        trudnosc: 0,
        lat: currentLocation[0],
        lng: currentLocation[1],
        dataDodania: firebase.firestore.FieldValue.serverTimestamp(),
        IDpinezki
      });
      const data = {
        id: IDpinezki,
        IDpinezki,
        firebaseId,
        nazwa: name,
        opis: '',
        warstwa: 'Tryb w ruchu',
        warstwaId: movingLayerId,
        kategoria: '',
        emoji: '',
        trudnosc: 0,
        lat: currentLocation[0],
        lng: currentLocation[1],
        dataDodania: Date.now(),
        slug: slugify(name)
      };
    const marker = L.marker(currentLocation, {icon: createEmojiIcon('', movingLayerId)}).addTo(warstwy['Tryb w ruchu'].layer);
    const popupDiv = document.createElement('div');
    popupDiv.className = 'popup-container';
    popupDiv.innerHTML = createPopupHtml(data);
    marker.bindPopup(popupDiv);
    attachPopupHandlers(marker, data);
    data.marker = marker;
    warstwy['Tryb w ruchu'].lista.push(data);
    wszystkiePinezki.push(data);
    generujListeWarstw();
  }

  function saveCenterPin(form) {
    const latlng = map.getCenter();
    const layerVal = form.warstwa.trim();
    if (layerVal && !warstwy[layerVal]) addLayer(layerVal);
    const catVal = form.kategoria.trim();
    if (catVal && !categories.has(catVal)) { categories.add(catVal); updateCategoryFilter(); }
    const newId = crypto.randomUUID();
    const data = {
      id: newId,
      IDpinezki: newId,
      nazwa: form.nazwa,
      opis: form.opis.replace(/\n/g, '<br>'),
      warstwa: layerVal,
      kategoria: catVal,
      emoji: form.emoji,
      trudnosc: parseInt(form.trudnosc, 10),
      nieaktywne: form.nieaktywne,
      zamkniete: form.zamkniete,
      tajne: form.tajne,
      doSprawdzenia: form.doSprawdzenia,
      zdewastowane: form.zdewastowane,
      zwiedzone: form.zwiedzone,
      wyroznione: form.wyroznione,
      odKogo: form.odKogo,
      lat: latlng.lat,
      lng: latlng.lng,
      dataDodania: Date.now(),
      unsaved: true,
      firebaseId: null
    };
    const warstwaN = data.warstwa || 'Inne';
    data.warstwaId = layerDocs[warstwaN] || null;
    if (!warstwy[warstwaN]) {
      warstwy[warstwaN] = { lista: [], layer: L.layerGroup().addTo(map), collapsed: true, emoji: '', loaded: true, loading: false, defaultVisible: true };
    }
    const marker = L.marker(latlng, {icon: createEmojiIcon(warstwy[warstwaN].emoji || data.emoji, data.warstwaId, 32, data)}).addTo(warstwy[warstwaN].layer);
    applyInactiveStyle(data);
    data.marker = marker;
    data.slug = slugify(data.nazwa);
    if (!photosMap[data.slug]) {
      storePhotos(data.slug, []);
    }
    categories.add(data.kategoria || '');
    selectedCategories.add(data.kategoria || '');
    updateCategoryFilter();
    const popupDiv = document.createElement('div');
    popupDiv.className = 'popup-container';
    popupDiv.innerHTML = createPopupHtml(data);
    marker.bindPopup(popupDiv);
    attachPopupHandlers(marker, data);
    nowePinezki.push(data);
    localStorage.setItem('nowePinezki', JSON.stringify(nowePinezki.map(p => {
      const {marker, ...rest} = p;
      return rest;
    })));
    warstwy[warstwaN].lista.push(data);
    wszystkiePinezki.push(data);
    generujListeWarstw();
    updateSaveButton();
  }

  function showPinSavedMessage() {
    const el = document.getElementById('pinSavedMessage');
    if (!el) return;
    el.style.display = 'block';
    setTimeout(() => {
      el.style.display = 'none';
    }, 3000);
  }

  function setupMobile() {
    if (setupMobile.initialized) return;
    setupMobile.initialized = true;
    const btn = document.getElementById('savePinBtn');
    const modal = document.getElementById('mobilePinModal');
    const ok = document.getElementById('mobilePinOk');
    const cancel = document.getElementById('mobilePinCancel');
    const gpsBtn = document.getElementById('gpsFollowBtn');
      const nameInput = document.getElementById('mobilePinName');
      const descInput = document.getElementById('mobilePinDesc');
      const layerInput = document.getElementById('mobilePinLayer');
      const catInput = document.getElementById('mobilePinCategory');
      const emojiInput = document.getElementById('mobilePinEmoji');
      const emojiPicker = document.getElementById('mobilePinEmojiPicker');
      const emojiWrapper = document.getElementById('mobileEmojiPickerWrapper');
      const inactiveInput = document.getElementById('mobilePinInactive');
      const closedInput = document.getElementById('mobilePinClosed');
      const secretInput = document.getElementById('mobilePinSecret');
      const todoInput = document.getElementById('mobilePinTodo');
      const destroyedInput = document.getElementById('mobilePinDestroyed');
      const visitedInput = document.getElementById('mobilePinVisited');
      const highlightedInput = document.getElementById('mobilePinHighlighted');
      const fromInput = document.getElementById('mobilePinFrom');
      const trudInput = document.getElementById('mobilePinTrudnosc');
      const trudLabel = document.getElementById('mobilePinTrudnoscLabel');
      const trudWrapper = document.getElementById('mobileTrudnoscWrapper');
      if (!btn || !modal || !ok || !cancel || !nameInput || !trudInput || !trudLabel || !trudWrapper) return;
      setupTrudnoscInput(trudInput, trudLabel);

      let mobileEmojiPickerInitialized = false;
      function refreshMobileEmojiPicker() {
        if (!emojiPicker || !emojiInput) return;
        if (!mobileEmojiPickerInitialized) {
          setupEmojiPickerForInput(emojiPicker, emojiInput);
          mobileEmojiPickerInitialized = true;
        } else {
          const preview = emojiPicker.querySelector('.emoji-picker-preview');
          const grid = emojiPicker.querySelector('.emoji-picker-grid');
          if (preview) {
            const val = (emojiInput.value || '').trim();
            preview.src = resolveEmoji(val) || 'https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png';
          }
          if (grid) grid.style.display = 'none';
        }
      }

    function openGpsModal() {
      nameInput.value = '';
      descInput.style.display = 'none';
      layerInput.style.display = 'none';
      catInput.style.display = 'none';
      emojiInput.value = '';
      if (emojiWrapper) emojiWrapper.style.display = 'none';
      if (emojiPicker) {
        const grid = emojiPicker.querySelector('.emoji-picker-grid');
        if (grid) grid.style.display = 'none';
      }
      inactiveInput.parentElement.style.display = 'none';
      closedInput.parentElement.style.display = 'none';
      secretInput.parentElement.style.display = 'none';
      todoInput.parentElement.style.display = 'none';
      destroyedInput.parentElement.style.display = 'none';
      visitedInput.parentElement.style.display = 'none';
        highlightedInput.parentElement.style.display = 'none';
        fromInput.style.display = 'none';
        trudWrapper.style.display = 'none';
        modal.style.display = 'flex';
      }

    function openCenterModal() {
      nameInput.value = '';
      descInput.value = '';
      layerInput.value = '';
      catInput.value = '';
      emojiInput.value = '';
      if (emojiWrapper) emojiWrapper.style.display = '';
      inactiveInput.checked = false;
      closedInput.checked = false;
      secretInput.checked = false;
      todoInput.checked = false;
      destroyedInput.checked = false;
      visitedInput.checked = false;
      highlightedInput.checked = false;
      descInput.style.display = '';
      layerInput.style.display = '';
      catInput.style.display = '';
      inactiveInput.parentElement.style.display = '';
      closedInput.parentElement.style.display = '';
      secretInput.parentElement.style.display = '';
      todoInput.parentElement.style.display = '';
      destroyedInput.parentElement.style.display = '';
      visitedInput.parentElement.style.display = '';
        highlightedInput.parentElement.style.display = '';
        fromInput.style.display = '';
        fromInput.value = '';
        trudWrapper.style.display = '';
        trudInput.value = 0;
        trudInput.dispatchEvent(new Event('input'));
        modal.style.display = 'flex';
        refreshMobileEmojiPicker();
        setupDropdownInput(layerInput, () => Object.keys(warstwy));
        setupDropdownInput(catInput, () => Array.from(categories).filter(c => c));
      }

    if (window.innerWidth <= 800) {
      btn.style.display = 'block';
      if (typeof map !== 'undefined' && map) {
        initGeolocation();
      } else {
        const iv = setInterval(() => {
          if (typeof map !== 'undefined' && map) {
            initGeolocation();
            clearInterval(iv);
          }
        }, 500);
      }
    }

    btn.addEventListener('click', () => {
      if (currentTool === 'pin') {
        openCenterModal();
      } else {
        openGpsModal();
      }
    });

    cancel.addEventListener('click', () => { modal.style.display = 'none'; });
    ok.addEventListener('click', async () => {
      const name = nameInput.value.trim();
      const layer = layerInput.value.trim();
      const missing = [];
      if (!name) missing.push('Wpisz nazwƒô pinezki');
      if (currentTool === 'pin' && !layer) missing.push('Wybierz warstwƒô');
      if (missing.length) { alert(missing.join('\n')); return; }
      if (currentTool === 'pin') {
        saveCenterPin({
          nazwa: name,
          opis: descInput.value,
          warstwa: layer,
          kategoria: catInput.value,
          emoji: emojiInput.value,
          nieaktywne: inactiveInput.checked,
          zamkniete: closedInput.checked,
          tajne: secretInput.checked,
          doSprawdzenia: todoInput.checked,
          zdewastowane: destroyedInput.checked,
          zwiedzone: visitedInput.checked,
          wyroznione: highlightedInput.checked,
          odKogo: fromInput.value,
          trudnosc: trudInput.value
        });
      } else {
        await saveMovingPin(name);
      }
      modal.style.display = 'none';
      showPinSavedMessage();
    });

    if (gpsBtn) {
      gpsBtn.addEventListener('click', () => {
        followGps = true;
        gpsBtn.style.display = 'none';
        if (currentLocation) {
          map.setView(currentLocation, map.getZoom());
        }
      });
    }
  }

  </script>
  <div id="deleteModal">
    <div id="deleteModalContent">
      <div>Czy na pewno chcesz usunƒÖƒá pinezkƒô?</div>
      <button id="deleteConfirmYes">TAK</button>
      <button id="deleteConfirmNo">NIE</button>
    </div>
  </div>
    <div id="layerDeleteModal">
      <div id="layerDeleteModalContent">
        <div>Czy na pewno chcesz usunƒÖƒá warstwƒô i wszystkie jej pinezki?</div>
        <button id="layerDeleteConfirmYes">TAK</button>
        <button id="layerDeleteConfirmNo">NIE</button>
      </div>
    </div>
  <div id="photoModal">
    <span id="photoModalClose">&#10005;</span>
    <span id="photoModalDelete" onclick="deleteCurrentPhoto()">üóëÔ∏è</span>
    <img id="photoModalImg" src="">
  </div>
  <img id="centerMarker" src="https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png" alt="center marker">
  <button id="savePinBtn">ZAPISZ PIN</button>
  <div id="pinSavedMessage">Zapisano pinezkƒô</div>
  <div id="gpsLoadingMessage">Wczytujƒô lokalizacjƒô GPS...</div>
  <div id="mobilePinModal" class="mobile-modal">
    <div class="mobile-modal-content">
      <input type="text" id="mobilePinName" placeholder="Nazwa pinezki" style="width: 100%">
      <textarea id="mobilePinDesc" placeholder="Opis" style="width: 100%; height: 100px"></textarea>
      <input type="text" id="mobilePinFrom" placeholder="Od kogo" style="width: 100%">
      <input type="text" id="mobilePinLayer" placeholder="Warstwa" style="width: 100%">
      <input type="text" id="mobilePinCategory" placeholder="Kategoria" style="width: 100%">
      <div id="mobileEmojiPickerWrapper" class="mobile-emoji-picker">
        <div id="mobilePinEmojiPicker" class="emoji-picker"></div>
        <input type="hidden" id="mobilePinEmoji">
      </div>
      <div class="trudnosc-wrapper" id="mobileTrudnoscWrapper">
        <div class="trudnosc-title">Poziom trudno≈õci</div>
        <input type="range" id="mobilePinTrudnosc" class="trudnosc-range" min="0" max="5" step="1" value="0">
        <div class="trudnosc-labels">
          <span>Nieznany</span><span>B.≈Çatwy</span><span>≈Åatwy</span><span>≈öredni</span><span>Trudny</span><span>B.trudny</span>
        </div>
        <div class="trudnosc-value" id="mobilePinTrudnoscLabel"></div>
      </div>
      <div class="status-grid">
        <label><input type="checkbox" id="mobilePinInactive"> Niedostƒôpne ‚õî</label>
        <label><input type="checkbox" id="mobilePinClosed"> Zamkniƒôte üîê</label>
        <label><input type="checkbox" id="mobilePinSecret"> Tajne ü§´</label>
        <label><input type="checkbox" id="mobilePinTodo"> Do sprawdzenia ‚ùî</label>
        <label><input type="checkbox" id="mobilePinDestroyed"> Zdewastowane üí•</label>
        <label><input type="checkbox" id="mobilePinVisited"> Zwiedzone <img src="https://upload.wikimedia.org/wikipedia/commons/0/03/Green_check.svg" width="16" height="16" class="checkmark-obrys"></label>
        <label><input type="checkbox" id="mobilePinHighlighted"> Wyr√≥≈ºnione ‚≠ê</label>
      </div>
      <div style="display:flex;gap:10px;justify-content:center;">
        <button id="mobilePinOk">Zapisz</button>
        <button id="mobilePinCancel">Anuluj</button>
      </div>
    </div>
  </div>
  <script type="module">
  // === Konfiguracja Firebase (wstaw tylko je≈õli nie inicjalizujesz gdzie indziej) ===
  const firebaseConfig = {
    apiKey: "AIzaSyBj8xPy81NaxFwHmBL3ni_UVjYKFZflyv0",
    authDomain: "exploridemap.firebaseapp.com",
    projectId: "exploridemap",
    storageBucket: "exploridemap.firebasestorage.app",
    messagingSenderId: "1074659589759",
    appId: "1:1074659589759:web:f8bdffc15d41d47ac8094a",
    measurementId: "G-2JHQZ6HXTM"
  };

  // === Firebase v10 ===
  import { initializeApp, getApps } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getFirestore, collection, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

  const app = getApps().length ? getApps()[0] : initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);
  const provider = new GoogleAuthProvider();

  // === CSS + UI (jak wcze≈õniej) ===
  const css = `
  .expe-modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.5);backdrop-filter:saturate(0.9) blur(2px);z-index:2147483000;display:none}
  .expe-modal{position:fixed;left:300px;top:24px;width:680px;max-width:calc(100vw - 340px);max-height:80vh;overflow:hidden;border-radius:16px;background:#151821;border:1px solid #202635;box-shadow:0 24px 60px rgba(0,0,0,.45)}
  .expe-hdr{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid #1e2430}
  .expe-hdr h3{margin:0;font:600 15px/1.2 system-ui,-apple-system,Segoe UI,Roboto}
  .expe-hdr .expe-close{background:transparent;color:#9aa3b2;border:none;font-size:20px;cursor:pointer}
  .expe-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .expe-login{background:#2b88ff;color:white;border:none;border-radius:10px;padding:8px 10px;font-weight:700;cursor:pointer}
  .expe-user{font:12px/1.2 system-ui;color:#9aa3b2;margin-right:8px}
  .expe-wrap{display:grid;grid-template-columns:320px 1fr;gap:12px;padding:12px}
  .expe-card{background:#0f131b;border:1px solid #222a39;border-radius:12px;padding:10px}
  .expe-lbl{display:block;font:500 12px/1.2 system-ui;color:#9aa3b2;margin:6px 0}
  .expe-inp{width:100%;background:#0b0f16;border:1px solid #1d2330;border-radius:10px;color:#e6e8eb;padding:10px 12px;font-size:14px;outline:none}
  .expe-btn{background:#7aa2f7;color:#0c1020;border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  .expe-btn[disabled]{opacity:.55;cursor:not-allowed}
  .expe-pill{background:#0f131b;border:1px solid #222a39;border-radius:999px;padding:6px 10px;font-size:12px;color:#cbd5e1}
  .expe-pill.ok{color:#3ddc97;border-color:#284c3f}
  .expe-pill.bad{color:#ff6b6b;border-color:#4c2b2b}
  .expe-log{height:48vh;min-height:260px;overflow:auto;background:#0b0f16;border:1px solid #1d2330;border-radius:10px;padding:10px;white-space:pre-wrap;font:12px ui-monospace,Consolas,Menlo}
  @media (max-width:820px){.expe-wrap{grid-template-columns:1fr}}
  `;
  const style = document.createElement('style'); style.textContent = css; document.head.appendChild(style);

  const emojiBtn = document.getElementById('emojiToolBtn');
  const isMobile = window.matchMedia('(max-width: 768px)').matches;
  if (isMobile && emojiBtn) { emojiBtn.style.display = 'none'; }
  if (!isMobile && emojiBtn) {
  const backdrop = document.createElement('div');
  backdrop.className = 'expe-modal-backdrop';
  backdrop.innerHTML = `
    <div class="expe-modal" role="dialog" aria-modal="true">
      <div class="expe-hdr">
        <h3>Masowa edycja pola <code>emoji</code> w <code>pinezki2</code></h3>
        <div class="expe-row">
          <span id="expe-user" class="expe-user">Niezalogowany</span>
          <button id="expe-login" class="expe-login">Zaloguj Google</button>
          <button class="expe-close" title="Zamknij">√ó</button>
        </div>
      </div>
      <div class="expe-wrap">
        <section class="expe-card">
          <label class="expe-lbl">S≈Çowa kluczowe (oddzielone przecinkami)</label>
          <input id="expe-kw" class="expe-inp" placeholder="np. fabryka, cementownia, kopalnia, pa≈Çac">
          <label class="expe-lbl" style="margin-top:10px">Warto≈õƒá do wpisania w polu <code>emoji</code></label>
          <input id="expe-emoji" class="expe-inp" placeholder="np. üìå lub URL SVG" />
          <div id="expe-emoji-picker" style="position:relative;margin-top:4px;"></div>
          <div style="height:1px;background:#1e2430;margin:10px 0"></div>
          <label class="expe-row"><input type="checkbox" id="expe-preview" checked> <span class="expe-lbl" style="margin:0">PodglƒÖd (bez zmian)</span></label>
          <label class="expe-row" style="margin-top:6px"><input type="checkbox" id="expe-whole"> <span class="expe-lbl" style="margin:0">Dopasowanie ca≈Çych s≈Ç√≥w</span></label>
          <label class="expe-row" style="margin-top:6px"><input type="checkbox" id="expe-exact"> <span class="expe-lbl" style="margin:0">Tylko pe≈Çna nazwa</span></label>
          <label class="expe-row" style="margin-top:6px"><input type="checkbox" id="expe-case"> <span class="expe-lbl" style="margin:0">Rozr√≥≈ºniaj wielko≈õƒá liter</span></label>
          <label class="expe-row" style="margin-top:6px"><input type="checkbox" id="expe-onlyempty"> <span class="expe-lbl" style="margin:0">Aktualizuj tylko, gdy <code>emoji</code> jest puste</span></label>
          <div style="height:1px;background:#1e2430;margin:10px 0"></div>
          <div class="expe-row">
            <button id="expe-start" class="expe-btn">Start</button>
            <button id="expe-stop" class="expe-btn" style="background:#3b4059;color:#cbd5e1" disabled>Stop</button>
          </div>
          <div class="expe-row" style="gap:8px;margin-top:8px">
            <span class="expe-pill">Znaleziono: <b id="expe-found">0</b></span>
            <span class="expe-pill ok">Zmieniono: <b id="expe-ok">0</b></span>
            <span class="expe-pill bad">B≈Çƒôdy: <b id="expe-bad">0</b></span>
            <span class="expe-pill">Pominiƒôto: <b id="expe-skip">0</b></span>
          </div>
        </section>
        <section class="expe-card">
          <strong style="display:block;margin-bottom:6px">Log</strong>
          <pre id="expe-log" class="expe-log" aria-live="polite"></pre>
        </section>
      </div>
    </div>`;
  document.body.appendChild(backdrop);

  const $ = (sel, root=document) => root.querySelector(sel);
  const els = {
    kw: $('#expe-kw'), emoji: $('#expe-emoji'),
    preview: $('#expe-preview'), whole: $('#expe-whole'),
    exact: $('#expe-exact'), kase: $('#expe-case'), onlyempty: $('#expe-onlyempty'),
    start: $('#expe-start'), stop: $('#expe-stop'),
    found: $('#expe-found'), ok: $('#expe-ok'), bad: $('#expe-bad'), skip: $('#expe-skip'),
    close: $('.expe-close'), modal: $('.expe-modal'),
    user: $('#expe-user'), login: $('#expe-login')
  };
  const logEl = $('#expe-log'); let abortFlag = false; let emojiToolChanged = false;
  setupEmojiToolPicker(document.getElementById('expe-emoji-picker'), els.emoji);
  function log(msg){ const t=new Date().toLocaleTimeString(); logEl.textContent+=`[${t}] ${msg}\n`; logEl.scrollTop=logEl.scrollHeight; }
  function setCounters({found, ok, bad, skip}){ if(found!=null)els.found.textContent=found; if(ok!=null)els.ok.textContent=ok; if(bad!=null)els.bad.textContent=bad; if(skip!=null)els.skip.textContent=skip; }
  function buildMatcher(keywords,{caseSensitive,wholeWord,exactName}){ const parts=keywords.map(k=>k.trim()).filter(Boolean).map(k=>k.replace(/[.*+?^${}()|[\\]\\]/g,'\\$&')); if(!parts.length)return null; let pattern; if(exactName){pattern = `^(${parts.join('|')})$`;} else {const b=wholeWord?'\\b':''; pattern = `${b}(${parts.join('|')})${b}`;} try{return new RegExp(pattern,caseSensitive?'':'i');}catch(e){log(`‚ùå B≈ÇƒÖd regex: ${e.message}`);return null;} }

  async function setupEmojiToolPicker(container, input) {
    if (!container || !input) return;
    await emojiListReady;
    container.style.position = 'relative';
    const preview = document.createElement('img');
    preview.className = 'emoji-picker-preview';
    preview.width = 28; preview.height = 28;
    function current() {
      const val = input.value.trim();
      const resolved = resolveEmoji(val);
      return resolved && resolved.startsWith('http') ? resolved : 'https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png';
    }
    preview.src = current();
    container.appendChild(preview);
    const grid = document.createElement('div');
    grid.className = 'emoji-picker-grid';
    const addBtn = document.createElement('button');
    addBtn.textContent = '+';
    addBtn.className = 'emoji-add-btn';
    addBtn.addEventListener('click', async e => {
      e.stopPropagation();
      const url = prompt('URL nowego emoji:');
      if (url) {
        const info = prompt('Nazwa nowego emoji:') || '';
        const id = await addEmojiToList(url, info, log);
        input.value = id;
        preview.src = url;
        grid.style.display = 'none';
      }
    });
    grid.appendChild(addBtn);
    function renderGrid() {
      grid.querySelectorAll('img[data-emoji-item="true"]').forEach(el => el.remove());
      emojiList.forEach(({id, url, info}) => {
        const img = document.createElement('img');
        img.dataset.emojiItem = 'true';
        img.src = url;
        if (info) { img.title = info; img.dataset.info = info; }
        img.addEventListener('click', e => {
          e.stopPropagation();
          input.value = id;
          preview.src = url;
          grid.style.display = 'none';
        });
        grid.insertBefore(img, addBtn);
      });
    }
    renderGrid();
    subscribeEmojiList(renderGrid);
    container.appendChild(grid);
    preview.addEventListener('click', e => {
      e.stopPropagation();
      grid.style.display = grid.style.display === 'grid' ? 'none' : 'grid';
    });
    document.addEventListener('click', e => {
      if (!container.contains(e.target)) grid.style.display = 'none';
    });
  }

  async function addEmojiToList(url, info = '', logger = console.log) {
    await emojiListReady;
    const nextNum = emojiList.reduce((m, e) => {
      const n = parseInt(String(e.id).replace('emoji', '')) || 0;
      return Math.max(m, n);
    }, 0) + 1;
    const newId = `emoji${nextNum}`;
    const data = { id: newId, url, info };
    emojiList.push(data);
    emojiMap[newId] = url;
    notifyEmojiListUpdated();
    try {
      await db.collection('emoji-list').doc(newId).set(data);
      logger(`üíæ Dodano ${newId} do Firebase`);
    } catch (e) {
      logger(`‚ùå B≈ÇƒÖd zapisu do Firebase: ${e.message}`);
    }
    return newId;
  }

  // Auth UI
  onAuthStateChanged(auth, user => {
    if (user) { els.user.textContent = `Zalogowany: ${user.email}`; els.login.textContent = 'Zmie≈Ñ konto'; }
    else { els.user.textContent = 'Niezalogowany'; els.login.textContent = 'Zaloguj Google'; }
  });
  els.login.addEventListener('click', async () => {
    try { await signInWithPopup(auth, provider); }
    catch(e){ log('‚ùå B≈ÇƒÖd logowania: ' + e.message); }
  });

  async function runUpdate(){
    await emojiListReady;
    const user = auth.currentUser;
    if (!els.preview.checked && !user) { log('‚ö†Ô∏è Musisz byƒá zalogowany, aby zapisywaƒá zmiany.'); return; }

    abortFlag = false; els.start.disabled = true; els.stop.disabled = false;
    setCounters({found:0, ok:0, bad:0, skip:0}); log('‚Äî START ‚Äî');

    const keywords = (els.kw.value || '').split(',').map(s=>s.trim()).filter(Boolean);
    const emojiVal = els.emoji.value || ''; const preview = els.preview.checked;
    const whole = els.whole.checked; const exact = els.exact.checked; const kase = els.kase.checked; const onlyEmpty = els.onlyempty.checked;
    if (!keywords.length){ log('‚ö†Ô∏è Brak s≈Ç√≥w kluczowych.'); reset(); return; }
    if (!emojiVal && !preview){ log('‚ö†Ô∏è Puste emoji (a tryb NIE jest podglƒÖdem).'); reset(); return; }

    const matcher = buildMatcher(keywords, {caseSensitive:kase, wholeWord:whole, exactName:exact}); if (!matcher){ reset(); return; }

    try{
      log('Szukam w "pinezki2"‚Ä¶');
      const snap = await getDocs(collection(db, 'pinezki2'));
      const matched = [];
      snap.forEach(docSnap => {
        const d = docSnap.data() || {}; const nazwa = (d.nazwa ?? '').toString();
        if (matcher.test(nazwa)) matched.push({ id: docSnap.id, ref: docSnap.ref, nazwa, currentEmoji: d.emoji });
      });
      setCounters({found: matched.length}); log(`Znaleziono ${matched.length} dokument√≥w.`);

      if (preview){ for (const m of matched){ log(`üîé [${m.id}] "${m.nazwa}" | emoji: ${JSON.stringify(m.currentEmoji)}`); if (abortFlag) break; } log('‚úÖ PodglƒÖd ‚Äì brak zapis√≥w.'); reset(); return; }

      const BATCH_LIMIT = 500; let ok=0,bad=0,skip=0;
      for (let i=0;i<matched.length && !abortFlag;i+=BATCH_LIMIT){
        const slice = matched.slice(i,i+BATCH_LIMIT);
        const batch = writeBatch(db); let writes=0;
        for (const m of slice){
          if (onlyEmpty && (m.currentEmoji!==undefined && m.currentEmoji!==null && m.currentEmoji!=='')){ skip++; setCounters({skip}); continue; }
          batch.update(m.ref, { emoji: emojiVal }); writes++; log(`‚úèÔ∏è [${m.id}] "${m.nazwa}" ‚Üí emoji = ${JSON.stringify(emojiVal)}`);
        }
        if (!writes) continue;
        try{ await batch.commit(); ok+=writes; setCounters({ok}); log(`‚úÖ Zapisano batch ${writes}.`); }
        catch(e){ bad+=writes; setCounters({bad}); log(`‚ùå B≈ÇƒÖd commit: ${e.message}`); }
      }
      log(`‚Äî KONIEC ‚Äî Zmieniono: ${ok} | Pominiƒôto: ${skip} | B≈Çƒôdy: ${bad}`);
      if (!preview && ok > 0) {
        emojiToolChanged = true;
        if (emojiVal.startsWith('http')) {
          const exists = emojiList.some(e => e.id === emojiVal || e.url === emojiVal);
          if (!exists) await addEmojiToList(emojiVal, '', log);
        }
      }
    }catch(e){ log('‚ùå B≈ÇƒÖd: ' + e.message); }
    finally{ reset(); }
  }

  function reset(){ els.start.disabled=false; els.stop.disabled=true; abortFlag=false; }
  emojiBtn.addEventListener('click', ()=>{ backdrop.style.display='block'; });
  els.close.addEventListener('click', ()=>{ backdrop.style.display='none'; if(emojiToolChanged) location.reload(); });
  backdrop.addEventListener('click', (e)=>{ if(e.target===backdrop){ backdrop.style.display='none'; if(emojiToolChanged) location.reload(); } });
  els.start.addEventListener('click', runUpdate);
  els.stop.addEventListener('click', ()=>{ abortFlag=true; els.stop.disabled=true; log('üõë Przerwano‚Ä¶'); });
  }
  </script>
</body>
</html>
